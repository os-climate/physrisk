from abc import abstractmethod
from collections import defaultdict
from dataclasses import dataclass
from typing import (
    Any,
    Dict,
    Iterable,
    List,
    Optional,
    Sequence,
    Set,
    Tuple,
    Union,
    cast,
)

import numpy as np
import pandas as pd
from pydantic import BaseModel, ConfigDict, Field
from physrisk.kernel.assets import Asset
from physrisk.kernel.curve import ExceedanceCurve
from physrisk.kernel.hazard_event_distrib import HazardEventDistrib
from physrisk.kernel.hazard_model import (
    HazardDataRequest,
    HazardDataResponse,
    HazardEventDataResponse,
    HazardParameterDataResponse,
)
from physrisk.kernel.hazards import ChronicHeat, PluvialInundation, RiverineInundation
from physrisk.kernel.impact_distrib import EmptyImpactDistrib, ImpactDistrib, ImpactType
from physrisk.kernel.vulnerability_distrib import VulnerabilityDistrib
from physrisk.kernel.vulnerability_model import (
    VulnerabilityModelAcuteBase,
    VulnerabilityModelBase,
)


def to_year_fraction_divisor(indicator_units: Optional[str]) -> float:
    if indicator_units is not None:
        if indicator_units == "days/year":
            return 365.0
        elif indicator_units == "weeks/year":
            return 52.0
        elif indicator_units == "months/year":
            return 12.0
    return 1.0


class VulnerabilityConfigItem(BaseModel):
    """Item of vulnerability configuration."""

    model_config = ConfigDict(arbitrary_types_allowed=True)
    hazard_class: str = Field(
        "",
        description="Name of the physrisk hazard class.",
        examples=["RiverineInundation"],
    )
    asset_class: str = Field(
        "",
        description="Name of physrisk asset class.",
        examples=["Asset", "RealEstateAsset"],
    )
    asset_identifier: str = Field(
        "",
        description="Asset identifier in form of asset attribute " "key-value pairs.",
        examples=[
            "type=Buildings/Commercial,location=Europe",
            "occ_scheme=OED,occ_id=100",
        ],
    )
    indicator_id: str = Field(
        "", description="Hazard indicator identifier.", examples=["flood_depth"]
    )
    indicator_units: Optional[str] = Field(
        "", description="Hazard indicator units.", examples=["metres"]
    )
    impact_id: str = Field(
        "damage",
        description="Identifier for the impact type.",
        examples=["damage", "disruption"],
    )
    impact_units: Optional[str] = Field("", description="Units of the impact type.")
    curve_type: str = Field(
        "indicator/piecewise_linear",
        description="Type of the curve expressing the vulnerability function.",
        examples=["indicator/piecewise_linear", "threshold/piecewise_linear"],
    )
    points_x: Optional[Union[Sequence[float], np.ndarray]] = Field(
        None,
        description="Array of x (indicator/threshold) components of points defining vulnerability "
        "curve/surface.",
    )
    points_y: Union[Sequence[float], np.ndarray] = Field(
        [],
        description="Array of y (impact) components of points defining vulnerability curve/surface.",
    )
    points_z: Optional[Union[Sequence[float], np.ndarray]] = Field(
        None,
        description="Describes z (probability) components of points defining vulnerability "
        "curve/surface. 1 or 2 dimensional array.",
    )
    cap_of_points_x: Optional[float] = Field(
        "", description="Cap of x (indicator/threshold)."
    )
    cap_of_points_y: Optional[float] = Field("", description="Cap of y (impact).")
    activation_of_points_x: Optional[float] = Field(
        "", description="Activation threshold of x (indicator/threshold)."
    )


@dataclass
class DowntimeConfigItem:
    asset_class: str  # Name of physrisk asset class, e.g. 'RealEstateAsset'.
    asset_identifier: str  # Identifier of the asset, within the class, e.g. 'type=Buildings/Commercial,location=Europe'.
    points_x: Sequence[float]
    points_y: Sequence[float]


def convert_curve(key: str, value: Any):
    if key == "points_x" or key == "points_y" or key == "points_z":
        if isinstance(value, str):
            return [
                float(x) for x in value.replace("[", "").replace("]", "").split(",")
            ]
    if isinstance(value, float):
        if np.isnan(value):
            return None
    return value


def convert_row(row: Dict[Any, Any]):
    return {k: convert_curve(k, v) for k, v in row.items()}


def config_items_to_df(
    config_items: Sequence[Union[VulnerabilityConfigItem, DowntimeConfigItem]],
):
    return pd.DataFrame(vars(c) for c in config_items)


def config_items_to_csv(
    config_items: Sequence[Union[VulnerabilityConfigItem, DowntimeConfigItem]],
    path: str,
):
    df = config_items_to_df(config_items)
    df.to_csv(path, index=False)


def config_items_from_df(df: pd.DataFrame):
    if "hazard_class" in df.columns:
        return df.apply(VulnerabilityConfigItem)
    return df.apply(DowntimeConfigItem)


def config_items_from_csv(path: str):
    df = pd.read_csv(path)
    column = "hazard_class"
    if column in df.columns:
        residual_df = df[df[column].str.contains(",")]
        df = df[~df.index.isin(residual_df.index)]
        while 0 < len(residual_df):
            additional_df = residual_df.copy(deep=True)
            additional_df[column] = residual_df[column].apply(lambda x: x.split(",")[0])
            residual_df[column] = residual_df[column].apply(
                lambda x: ",".join(x.split(",")[1:])
            )
            residual_df = residual_df[residual_df[column] != ""]
            df = pd.concat([df, additional_df])
        return df.apply(lambda row: VulnerabilityConfigItem(**convert_row(row)), axis=1)
    else:
        return df.apply(lambda row: DowntimeConfigItem(**convert_row(row)), axis=1)


class ImpactCurveKey:
    def __init__(self, asset_identifier: str):
        self.identifier = ImpactCurveKey.to_dict(asset_identifier)

    def __hash__(self):
        return hash(ImpactCurveKey.from_dict(self.identifier))

    def __eq__(self, other):
        if isinstance(other, ImpactCurveKey):
            return self.identifier.items() == other.identifier.items()
        return False

    def __ne__(self, other):
        return not self.__eq__(other)

    @staticmethod
    def to_dict(identifier: str) -> Dict[str, str]:
        if 0 < len(identifier):
            my_dict = dict(key_value.split("=") for key_value in identifier.split(","))
            return dict(
                (key.lower(), value.upper())
                for (key, value) in sorted(my_dict.items())
                if value.upper() != "GENERIC"
            )
        else:
            return defaultdict()

    @staticmethod
    def from_dict(identifier: Dict[str, str]) -> str:
        return ",".join(
            ["=".join([key, str(value)]) for key, value in identifier.items()]
        )

    @staticmethod
    def get(asset: Asset, attributes: Set[str], keys: Optional[Iterable[Any]] = None):
        key = ImpactCurveKey(
            ImpactCurveKey.from_dict(
                {
                    attribute: getattr(asset, attribute)
                    for attribute in attributes
                    if hasattr(asset, attribute)
                }
            )
        )
        if keys is not None and key not in keys:
            for pattern in [["location"], ["type"], ["location", "type"]]:
                reduced_key = ImpactCurveKey(
                    ImpactCurveKey.from_dict(
                        {
                            key: value
                            for key, value in key.identifier.items()
                            if key not in pattern
                        }
                    )
                )
                if reduced_key in keys:
                    return reduced_key
            raise ValueError("Failed to map asset to an impact curve.")
        return key


class ImpactCurve:
    def __init__(
        self,
        curve_type: str,
        cap_of_points_x: Optional[float],
        cap_of_points_y: Optional[float],
        activation_of_points_x: Optional[float],
    ):
        assert curve_type in ["indicator", "threshold"]
        self.curve_type = curve_type
        self.cap_of_points_x = cap_of_points_x
        self.cap_of_points_y = cap_of_points_y
        self.activation_of_points_x = activation_of_points_x

    @abstractmethod
    def get_impact(self, points_x: np.ndarray) -> np.ndarray: ...

    @staticmethod
    def get_impact_curve(item: VulnerabilityConfigItem):
        curve_type = item.curve_type.split("/")[0]
        cap_of_points_y = item.cap_of_points_y
        points_y = np.array(item.points_y)
        if item.points_x is None:
            assert len(item.points_y) == 1
            points_x = np.zeros(len(item.points_y))
        else:
            points_x = np.array(item.points_x)
        if item.curve_type.split("/")[-1] == "parametric":
            return ParametricImpactCurve(
                curve_type=curve_type,
                points_x=points_x,
                points_y=points_y,
                cap_of_points_x=item.cap_of_points_x,
                cap_of_points_y=cap_of_points_y,
                activation_of_points_x=item.activation_of_points_x,
            )
        return PiecewiseLinearImpactCurve(
            curve_type=curve_type,
            points_x=points_x,
            points_y=points_y,
            cap_of_points_x=item.cap_of_points_x,
            cap_of_points_y=cap_of_points_y,
            activation_of_points_x=item.activation_of_points_x,
        )


class PiecewiseLinearImpactCurve(ImpactCurve):
    def __init__(
        self,
        curve_type: str,
        points_x: np.ndarray,
        points_y: np.ndarray,
        cap_of_points_x: Optional[float],
        cap_of_points_y: Optional[float],
        activation_of_points_x: Optional[float],
    ):
        super().__init__(
            curve_type, cap_of_points_x, cap_of_points_y, activation_of_points_x
        )
        self.points_x = points_x
        self.points_y = points_y

    def get_impact(self, points_x: np.ndarray) -> np.ndarray:
        if self.cap_of_points_x is not None:
            points_x[self.cap_of_points_x < points_x] = self.cap_of_points_x
        points_y = np.interp(points_x, self.points_x, self.points_y)
        if self.cap_of_points_y is not None:
            points_y[self.cap_of_points_y < points_y] = self.cap_of_points_y
        if self.activation_of_points_x is not None:
            points_y[points_x <= self.activation_of_points_x] = 0.0
        return points_y


class ParametricImpactCurve(ImpactCurve):
    def __init__(
        self,
        curve_type: str,
        points_x: np.ndarray,
        points_y: np.ndarray,
        cap_of_points_x: Optional[float],
        cap_of_points_y: Optional[float],
        activation_of_points_x: Optional[float],
    ):
        assert activation_of_points_x is not None
        assert cap_of_points_y is not None
        assert len(points_x) == 1
        assert len(points_y) == 1
        super().__init__(
            curve_type, cap_of_points_x, cap_of_points_y, activation_of_points_x
        )
        if self.cap_of_points_y == 0.0:
            self.scale = 1.0
        else:
            self.scale = (points_x[0] - activation_of_points_x) / np.log(
                1.0 / (1.0 - (points_y[0] / self.cap_of_points_y))
            )

    def get_impact(self, points_x: np.ndarray) -> np.ndarray:
        if self.cap_of_points_x is not None:
            points_x[self.cap_of_points_x < points_x] = self.cap_of_points_x
        if self.cap_of_points_y is not None and self.activation_of_points_x is not None:
            return np.array(
                [
                    (
                        0.0
                        if point_x < self.activation_of_points_x
                        else self.cap_of_points_y
                        * (
                            1.0
                            - np.exp(
                                -(point_x - self.activation_of_points_x) / self.scale
                            )
                        )
                    )
                    for point_x in points_x
                ]
            )
        return np.zeros(len(points_x))


class ConfigBasedVulnerabilityModel(VulnerabilityModelBase):
    def __init__(
        self,
        *,
        asset_class: str,  # type of the asset class
        hazard_class: type,  # type of the hazard class
        impact_id: str,
        config_items: Sequence[VulnerabilityConfigItem],
    ):
        """A vulnerability model that requires only specification of a set of damage/disruption curves
        which are provided by configuration. This simple model contains no uncertainty around damage/disruption.
        The edges of the (hazard) intensity bins are determined by the granularity of the hazard data itself.
        The impact bin edges are inferred from the intensity bin edges, by looking up the impact corresponding
        to the hazard indicator intensity from the damage curve.
        """
        impact_type = (
            ImpactType.damage if impact_id == "damage" else ImpactType.disruption
        )
        indicator_id = config_items[0].indicator_id

        super().__init__(indicator_id, hazard_class, impact_type)

        self.asset_class = asset_class
        self.curves = {
            ImpactCurveKey(item.asset_identifier): ImpactCurve.get_impact_curve(item)
            for item in config_items
        }
        self.asset_attributes = set(
            key for curve in self.curves for key in curve.identifier.keys()
        )

        self.to_year_fraction_divisor = to_year_fraction_divisor(
            config_items[0].indicator_units
        )

        self.thresholds = None
        if (
            self.hazard_type == ChronicHeat
            and self.indicator_id == "days_tas/above/{temp_c}c"
        ):
            self.thresholds = np.array(range(25, 60, 5))

    def get_data_requests(
        self, asset: Asset, *, scenario: str, year: int
    ) -> Union[HazardDataRequest, Iterable[HazardDataRequest]]:
        if (
            self.thresholds is not None
            and self.hazard_type == ChronicHeat
            and self.indicator_id == "days_tas/above/{temp_c}c"
        ):
            return [
                HazardDataRequest(
                    self.hazard_type,
                    asset.longitude,
                    asset.latitude,
                    scenario=scenario,
                    year=year,
                    indicator_id=self.indicator_id.format(temp_c=str(int(threshold))),
                )
                for threshold in self.thresholds
            ]
        return HazardDataRequest(
            self.hazard_type,
            asset.longitude,
            asset.latitude,
            scenario=scenario,
            year=year,
            indicator_id=self.indicator_id,
        )

    def get_impact(
        self, asset: Asset, hazard_data: Sequence[HazardDataResponse]
    ) -> ImpactDistrib:
        curve = self.curves[
            ImpactCurveKey.get(asset, self.asset_attributes, self.curves.keys())
        ]

        if isinstance(hazard_data[0], HazardEventDataResponse):
            intensity_curve = ExceedanceCurve(
                1.0 / hazard_data[0].return_periods, hazard_data[0].intensities
            )
            intensity_bins, probability_bins = intensity_curve.get_probability_bins(
                include_last=True
            )
            impact_bins = curve.get_impact(intensity_bins)
            path = hazard_data[0].path

        else:
            assert isinstance(hazard_data[0], HazardParameterDataResponse)
            path = hazard_data[0].path
            indicators = np.concatenate(
                [
                    cast(HazardParameterDataResponse, response).parameters
                    for response in hazard_data
                ]
            )
            if len(indicators) == 0:
                return EmptyImpactDistrib()

            if curve.curve_type == "indicator":
                assert len(indicators) == 1
                probability_bins = np.array([1.0])
                impact_bins = curve.get_impact(indicators)
            else:
                exceedance_probabilities = indicators / self.to_year_fraction_divisor
                if hazard_data[0].path.startswith("fire/jupiter/v1/fire_probability_"):
                    # The annual probability of fire being within 100km the grid square, a scaling
                    # factor of 1/500 is applied to approximate a high resolution probability of fire.
                    exceedance_probabilities /= 500.0
                probability_bins = (
                    exceedance_probabilities[:-1] - exceedance_probabilities[1:]
                )
                probability_bins = np.append(
                    probability_bins, exceedance_probabilities[-1]
                )
                thresholds = (
                    np.concatenate(
                        [
                            cast(HazardParameterDataResponse, response).param_defns
                            for response in hazard_data
                        ]
                    )
                    if self.thresholds is None
                    else self.thresholds
                )
                impact_bins = curve.get_impact(thresholds)

            impact_bins = np.append(impact_bins, impact_bins[-1])

        return ImpactDistrib(
            self.hazard_type, impact_bins, probability_bins, [path], self.impact_type
        )


class ConfigBasedVulnerabilityModelAcute(VulnerabilityModelAcuteBase):
    def __init__(
        self,
        *,
        asset_class: str,  # type of the asset class
        hazard_class: type,  # type of the hazard class
        impact_id: str,
        config_items: Sequence[VulnerabilityConfigItem],
        disable_api_calls: bool,
    ):
        """A vulnerability model that requires only specification of a set of damage/disruption curves
        which are provided by configuration. This simple model contains no uncertainty around damage/disruption.
        The edges of the (hazard) intensity bins are determined by the granularity of the hazard data itself.
        The impact bin edges are inferred from the intensity bin edges, by looking up the impact corresponding
        to the hazard indicator intensity from the damage curve.
        """
        impact_type = (
            ImpactType.damage if impact_id == "damage" else ImpactType.disruption
        )
        indicator_id = config_items[0].indicator_id

        super().__init__(indicator_id, hazard_class, impact_type)

        self.asset_class_type = asset_class
        self.curves = {
            ImpactCurveKey(item.asset_identifier): ImpactCurve.get_impact_curve(item)
            for item in config_items
        }
        self.has_sop = not (disable_api_calls) and (
            (hazard_class == RiverineInundation) or (hazard_class == PluvialInundation)
        )
        self.asset_attributes = set(
            key for curve in self.curves for key in curve.identifier.keys()
        )

    def get_data_requests(
        self, asset: Asset, *, scenario: str, year: int
    ) -> Union[HazardDataRequest, Iterable[HazardDataRequest]]:
        future = HazardDataRequest(
            self.hazard_type,
            asset.longitude,
            asset.latitude,
            scenario=scenario,
            year=year,
            indicator_id=self.indicator_id,
        )
        if not self.has_sop:
            return future
        # if the acute model includes standard of protection, then we request the historical curve and (hisorical) SoP
        # some haazrd models (e.g. JBA) will give a future-adjusted SoP, but generally we need to infer this.
        histo = HazardDataRequest(
            self.hazard_type,
            asset.longitude,
            asset.latitude,
            scenario="historical",
            year=year,  # will be ignored (consider making field optional?)
            indicator_id=self.indicator_id,
        )
        sop = HazardDataRequest(
            self.hazard_type,
            asset.longitude,
            asset.latitude,
            scenario="historical",
            year=year,
            indicator_id=self._sop_id_for_hazard(self.hazard_type),
        )
        return [future, histo, sop]

    def _sop_id_for_hazard(self, hazard_type: type):
        if (hazard_type == RiverineInundation) or (hazard_type == PluvialInundation):
            return "flood_sop"
        else:
            raise NotImplementedError(
                f"sop not available for hazard {hazard_type.__name__}"
            )

    def get_distributions(
        self, asset: Asset, data_responses: Iterable[HazardDataResponse]
    ) -> Tuple[VulnerabilityDistrib, HazardEventDistrib]:
        if self.has_sop:
            (future, histo, sop) = data_responses
        else:
            (future,) = data_responses

        assert isinstance(future, HazardEventDataResponse)
        intensity_curve = ExceedanceCurve(
            1.0 / future.return_periods, future.intensities
        )

        # sop = getattr(future, "sop", 0)  # standard of protection in years
        if self.has_sop:
            assert isinstance(histo, HazardEventDataResponse)
            assert isinstance(sop, HazardParameterDataResponse)
            if sop.parameter > 0:
                histo_curve = ExceedanceCurve(
                    1.0 / histo.return_periods, histo.intensities
                )
                # we infer protected depth from the historical curve...
                protected_depth = histo_curve.get_value(1.0 / sop.parameter)
                if protected_depth > 0:
                    # and assume this protected depth in the future scenario (if not the same)
                    # with a modification to underlying functions we can do this in one step, but for now:
                    c = intensity_curve.add_value_point(protected_depth)
                    i = np.searchsorted(c.values, protected_depth)
                    intensity_curve = ExceedanceCurve(c.probs[i:], c.values[i:])

        intensity_bins, probability_bins = intensity_curve.get_probability_bins(
            include_last=True
        )

        curve = self.curves[
            ImpactCurveKey.get(asset, self.asset_attributes, self.curves.keys())
        ]
        impact_bins = curve.get_impact(intensity_bins)

        vul = VulnerabilityDistrib(
            type(self.hazard_type),
            intensity_bins,
            impact_bins,
            np.eye(len(probability_bins)),
        )
        event = HazardEventDistrib(
            type(self.hazard_type), intensity_bins, probability_bins, path=[future.path]
        )

        return vul, event

    def _get_probability_bins(
        self, values, probs, include_last: bool = False, sop: int = 0
    ):
        r"""Convert from exceedance (cumulative) probability to bins of constant probability density.
        This is equivalent to the assumption of linear interpolation of exceedance points.

        .. math::
            p^\text{b}_i = p^\text{e}_{i + 1} - p^\text{e}_i

        Returns:
            value_bins (ndarray), probs: The contiguous bin lower and upper values, probabilities of each bin.
            If value_bins is of length n then there are n-1 bins and n-1 probabilities

        """
        # if there is a sop, then

        value_bins = values[:]
        probs = probs[:-1] - probs[1:]  # type: ignore
        if include_last or len(values) == 1:
            value_bins = np.append(
                value_bins, value_bins[-1]
            )  # last bin has zero width
            probs = np.append(probs, probs[-1])
        return value_bins, probs
