from typing import (
    Sequence,
    Tuple,
    Union,
)

import numpy as np
from pint import UnitRegistry
from physrisk.kernel.assets import Asset, ThermalPowerGeneratingAsset
from physrisk.kernel.curve import ExceedanceCurve
from physrisk.kernel.hazard_event_distrib import (
    EmptyHazardEventDistrib,
    HazardEventDistrib,
)
from physrisk.kernel.hazard_model import (
    HazardDataRequest,
    HazardDataResponse,
    HazardEventDataResponse,
    HazardParameterDataResponse,
)
from physrisk.kernel.hazards import (
    CoastalInundation,
    PluvialInundation,
    RiverineInundation,
)
from physrisk.kernel.impact_distrib import ImpactType
from physrisk.kernel.vulnerability_distrib import (
    EmptyVulnerabilityDistrib,
    VulnerabilityDistrib,
)
from physrisk.kernel.vulnerability_model import VulnerabilityModelAcuteBase
from physrisk.vulnerability_models.config_based_impact_curves import (
    ImpactCurve,
    ImpactCurveKey,
    VulnerabilityConfigItem,
)
from physrisk.vulnerability_models.config_cdf_based_vuln_function import (
    CDFBasedVulnerabilityFunction,
)

ureg = UnitRegistry()


class ConfigBasedVulnerabilityModelAcute(VulnerabilityModelAcuteBase):
    def __init__(
        self,
        *,
        asset_class: str,  # type of the asset class
        hazard_class: type,  # type of the hazard class
        impact_id: str,
        config_items: Sequence[VulnerabilityConfigItem],
    ):
        """A vulnerability model that requires only specification of a set of damage/disruption curves
        which are provided by configuration. This simple model contains no uncertainty around damage/disruption.
        The edges of the (hazard) intensity bins are determined by the granularity of the hazard data itself.
        The impact bin edges are inferred from the intensity bin edges, by looking up the impact corresponding
        to the hazard indicator intensity from the damage curve.
        """
        impact_type = (
            ImpactType.damage if impact_id == "damage" else ImpactType.disruption
        )
        indicator_id = config_items[0].indicator_id

        super().__init__(indicator_id, hazard_class, impact_type)

        self.asset_class_type = asset_class
        self.curves = {
            ImpactCurveKey(item.asset_identifier): ImpactCurve.get_impact_curve(item)
            for item in config_items
        }
        self.has_sop = hazard_class in [CoastalInundation, RiverineInundation]
        self.asset_attributes = set(
            key for curve in self.curves for key in curve.identifier.keys()
        )

    def get_data_requests(
        self, asset: Asset, *, scenario: str, year: int
    ) -> Union[HazardDataRequest, Sequence[HazardDataRequest]]:
        future = HazardDataRequest(
            self.hazard_type,
            asset.longitude,
            asset.latitude,
            scenario=scenario,
            year=year,
            indicator_id=self.indicator_id,
        )
        if not self.has_sop:
            return future
        # if the acute model includes standard of protection, then we request the historical curve and (hisorical) SoP
        # some haazrd models (e.g. JBA) will give a future-adjusted SoP, but generally we need to infer this.
        histo = HazardDataRequest(
            self.hazard_type,
            asset.longitude,
            asset.latitude,
            scenario="historical",
            year=year,  # will be ignored (consider making field optional?)
            indicator_id=self.indicator_id,
        )
        if not self.hazard_type == RiverineInundation:
            return [future, histo]
        # we only have standard of protection hazard indicators for RiverineInundation:
        sop = HazardDataRequest(
            self.hazard_type,
            asset.longitude,
            asset.latitude,
            scenario="historical",
            year=year,
            indicator_id=self._sop_id_for_hazard(self.hazard_type),
        )
        return [future, histo, sop]

    def _sop_id_for_hazard(self, hazard_type: type):
        if self._is_flood():
            return "flood_sop"
        else:
            raise NotImplementedError(
                f"sop not available for hazard {hazard_type.__name__}"
            )

    def get_distributions(
        self, asset: Asset, data_responses: Sequence[HazardDataResponse]
    ) -> Tuple[VulnerabilityDistrib, HazardEventDistrib]:
        standard_of_protection = 0.0
        if self.has_sop:
            if len(data_responses) == 3:
                (future, histo, sop) = data_responses
                assert isinstance(sop, HazardParameterDataResponse)
                standard_of_protection = sop.parameter
            else:
                (future, histo) = data_responses
        else:
            (future,) = data_responses

        assert isinstance(future, HazardEventDataResponse)

        resolved_key = ImpactCurveKey.get(
            asset, self.asset_attributes, self.curves.keys()
        )
        if resolved_key is None:
            return EmptyVulnerabilityDistrib(), EmptyHazardEventDistrib()
        curve = self.curves[resolved_key]
        fut_intensities = future.intensities
        conversion = curve.indicator_units is not None and future.units != "default"
        if conversion:
            fut_intensities = ureg.convert(
                fut_intensities, future.units, curve.indicator_units
            )

        intensity_curve = ExceedanceCurve(1.0 / future.return_periods, fut_intensities)

        standard_of_protection = self._asset_specific_sop(asset, standard_of_protection)

        if standard_of_protection > 0:
            assert isinstance(histo, HazardEventDataResponse)
            histo_intensities = histo.intensities
            if conversion:
                histo_intensities = ureg.convert(
                    histo_intensities, histo.units, curve.indicator_units
                )

            histo_curve = ExceedanceCurve(1.0 / histo.return_periods, histo_intensities)
            # we infer protected depth from the historical curve...
            protected_depth = histo_curve.get_value(1.0 / standard_of_protection)
            if protected_depth > 0:
                # and assume this protected depth in the future scenario (if not the same)
                # with a modification to underlying functions we can do this in one step, but for now:
                c = intensity_curve.add_value_point(protected_depth)
                i = np.searchsorted(c.values, protected_depth)
                intensity_curve = ExceedanceCurve(c.probs[i:], c.values[i:])

        indicator_bin_edges, probabilities = intensity_curve.get_probability_bins(
            include_last=True
        )

        if isinstance(curve, ImpactCurve):
            impact_bin_edges = curve.get_impact(indicator_bin_edges)
        elif isinstance(curve, CDFBasedVulnerabilityFunction):
            raise NotImplementedError()

        vul = VulnerabilityDistrib(
            type(self.hazard_type),
            indicator_bin_edges,
            impact_bin_edges,
            np.eye(len(probabilities)),
        )
        event = HazardEventDistrib(
            type(self.hazard_type),
            indicator_bin_edges,
            probabilities,
            path=[future.path],
        )
        return vul, event

    def _asset_specific_sop(self, asset: Asset, standard_of_protection: float):
        if self._is_flood():
            if isinstance(asset, ThermalPowerGeneratingAsset):
                standard_of_protection = max(
                    standard_of_protection,
                    asset.get_inundation_protection_return_period(),
                )
        return standard_of_protection

    def _is_flood(self):
        return self.hazard_type in [
            CoastalInundation,
            PluvialInundation,
            RiverineInundation,
        ]
