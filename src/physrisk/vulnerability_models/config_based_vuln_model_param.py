from typing import (
    Sequence,
    Union,
    cast,
)

import numpy as np
from physrisk.kernel.assets import Asset
from physrisk.kernel.curve import ExceedanceCurve
from physrisk.kernel.hazard_model import (
    HazardDataRequest,
    HazardDataResponse,
    HazardEventDataResponse,
    HazardParameterDataResponse,
)
from physrisk.kernel.hazards import ChronicHeat
from physrisk.kernel.impact_distrib import EmptyImpactDistrib, ImpactDistrib, ImpactType
from physrisk.kernel.vulnerability_model import VulnerabilityModelBase
from physrisk.vulnerability_models.config_based_impact_curves import (
    ImpactCurve,
    ImpactCurveKey,
    VulnerabilityConfigItem,
    to_year_fraction_divisor,
)


class ConfigBasedVulnerabilityModel(VulnerabilityModelBase):
    def __init__(
        self,
        *,
        asset_class: str,  # type of the asset class
        hazard_class: type,  # type of the hazard class
        impact_id: str,
        config_items: Sequence[VulnerabilityConfigItem],
    ):
        """A vulnerability model that requires only specification of a set of damage/disruption curves
        which are provided by configuration. This simple model contains no uncertainty around damage/disruption.
        The edges of the (hazard) intensity bins are determined by the granularity of the hazard data itself.
        The impact bin edges are inferred from the intensity bin edges, by looking up the impact corresponding
        to the hazard indicator intensity from the damage curve.
        """
        impact_type = (
            ImpactType.damage if impact_id == "damage" else ImpactType.disruption
        )
        indicator_id = config_items[0].indicator_id

        super().__init__(indicator_id, hazard_class, impact_type)

        self.asset_class = asset_class
        self.curves = {
            ImpactCurveKey(item.asset_identifier): ImpactCurve.get_impact_curve(item)
            for item in config_items
        }
        self.asset_attributes = set(
            key for curve in self.curves for key in curve.identifier.keys()
        )

        self.to_year_fraction_divisor = to_year_fraction_divisor(
            config_items[0].indicator_units
        )

        self.thresholds = None
        if (
            self.hazard_type == ChronicHeat
            and self.indicator_id == "days_tas/above/{temp_c}c"
        ):
            self.thresholds = np.array(range(25, 60, 5))

    def get_data_requests(
        self, asset: Asset, *, scenario: str, year: int
    ) -> Union[HazardDataRequest, Sequence[HazardDataRequest]]:
        if (
            self.thresholds is not None
            and self.hazard_type == ChronicHeat
            and self.indicator_id == "days_tas/above/{temp_c}c"
        ):
            return [
                HazardDataRequest(
                    self.hazard_type,
                    asset.longitude,
                    asset.latitude,
                    scenario=scenario,
                    year=year,
                    indicator_id=self.indicator_id.format(temp_c=str(int(threshold))),
                )
                for threshold in self.thresholds
            ]
        return HazardDataRequest(
            self.hazard_type,
            asset.longitude,
            asset.latitude,
            scenario=scenario,
            year=year,
            indicator_id=self.indicator_id,
        )

    def get_impact(
        self, asset: Asset, hazard_data: Sequence[HazardDataResponse]
    ) -> ImpactDistrib:
        resolved_key = ImpactCurveKey.get(
            asset, self.asset_attributes, self.curves.keys()
        )
        if resolved_key is None:
            return EmptyImpactDistrib()
        curve = self.curves[resolved_key]

        if isinstance(hazard_data[0], HazardEventDataResponse):
            intensity_curve = ExceedanceCurve(
                1.0 / hazard_data[0].return_periods, hazard_data[0].intensities
            )
            intensity_bins, probability_bins = intensity_curve.get_probability_bins(
                include_last=True
            )
            impact_bins = curve.get_impact(intensity_bins)
            path = hazard_data[0].path

        else:
            assert isinstance(hazard_data[0], HazardParameterDataResponse)
            path = hazard_data[0].path
            indicators = np.concatenate(
                [
                    cast(HazardParameterDataResponse, response).parameters
                    for response in hazard_data
                ]
            )
            if len(indicators) == 0:
                return EmptyImpactDistrib()

            if curve.curve_type == "indicator":
                assert len(indicators) == 1
                probability_bins = np.array([1.0])
                impact_bins = curve.get_impact(indicators)
            else:
                exceedance_probabilities = indicators / self.to_year_fraction_divisor
                if hazard_data[0].path.startswith("fire/jupiter/v1/fire_probability_"):
                    # The annual probability of fire being within 100km the grid square, a scaling
                    # factor of 1/500 is applied to approximate a high resolution probability of fire.
                    exceedance_probabilities /= 500.0
                probability_bins = (
                    exceedance_probabilities[:-1] - exceedance_probabilities[1:]
                )
                probability_bins = np.append(
                    probability_bins, exceedance_probabilities[-1]
                )
                thresholds = (
                    np.concatenate(
                        [
                            cast(HazardParameterDataResponse, response).param_defns
                            for response in hazard_data
                        ]
                    )
                    if self.thresholds is None
                    else self.thresholds
                )
                impact_bins = curve.get_impact(thresholds)

            impact_bins = np.append(impact_bins, impact_bins[-1])

        return ImpactDistrib(
            self.hazard_type, impact_bins, probability_bins, [path], self.impact_type
        )
