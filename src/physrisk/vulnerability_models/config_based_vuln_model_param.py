from typing import (
    Sequence,
    Union,
    cast,
)

import numpy as np
from physrisk.kernel.assets import Asset
from physrisk.kernel.curve import ExceedanceCurve
from physrisk.kernel.hazard_model import (
    HazardDataRequest,
    HazardDataResponse,
    HazardEventDataResponse,
    HazardParameterDataResponse,
)
from physrisk.kernel.hazards import ChronicHeat
from physrisk.kernel.impact_distrib import EmptyImpactDistrib, ImpactDistrib, ImpactType
from physrisk.kernel.vulnerability_model import VulnerabilityModelBase
from physrisk.vulnerability_models.config_based_impact_curves import (
    ParametricImpactCurve,
    PiecewiseLinearImpactCurve,
    to_year_fraction_divisor,
)
from physrisk.vulnerability_models.impact_function_selector import (
    ImpactFunctionSelector,
)


class ConfigBasedVulnerabilityModel(VulnerabilityModelBase):
    def __init__(
        self,
        *,
        hazard_class: type[Asset],  # type of the hazard class
        indicator_id: str,
        impact_type: ImpactType,
        selector: ImpactFunctionSelector,
    ):
        """A vulnerability model that requires only specification of a set of damage/disruption curves
        which are provided by configuration. This simple model contains no uncertainty around damage/disruption.
        The edges of the (hazard) intensity bins are determined by the granularity of the hazard data itself.
        The impact bin edges are inferred from the intensity bin edges, by looking up the impact corresponding
        to the hazard indicator intensity from the damage curve.
        """
        super().__init__(indicator_id, hazard_class, impact_type)
        self.selector = selector
        self.thresholds = None
        if (
            self.hazard_type == ChronicHeat
            and self.indicator_id == "days_tas/above/{temp_c}c"
        ):
            self.thresholds = np.array(range(25, 60, 5))

    def get_data_requests(
        self, asset: Asset, *, scenario: str, year: int
    ) -> Union[HazardDataRequest, Sequence[HazardDataRequest]]:
        if (
            self.thresholds is not None
            and self.hazard_type == ChronicHeat
            and self.indicator_id == "days_tas/above/{temp_c}c"
        ):
            return [
                HazardDataRequest(
                    self.hazard_type,
                    asset.longitude,
                    asset.latitude,
                    scenario=scenario,
                    year=year,
                    indicator_id=self.indicator_id.format(temp_c=str(int(threshold))),
                )
                for threshold in self.thresholds
            ]
        return HazardDataRequest(
            self.hazard_type,
            asset.longitude,
            asset.latitude,
            scenario=scenario,
            year=year,
            indicator_id=self.indicator_id,
        )

    def get_impact(
        self, asset: Asset, hazard_data: Sequence[HazardDataResponse]
    ) -> ImpactDistrib:
        curve = self.selector.select(
            asset, self.hazard_type, self.indicator_id, self.impact_type
        )
        if curve is None:
            return EmptyImpactDistrib()
        assert isinstance(
            curve, (ParametricImpactCurve, PiecewiseLinearImpactCurve)
        )  # for mypy

        if isinstance(hazard_data[0], HazardEventDataResponse):
            intensity_curve = ExceedanceCurve(
                1.0 / hazard_data[0].return_periods, hazard_data[0].intensities
            )
            intensity_bins, probability_bins = intensity_curve.get_probability_bins(
                include_last=True
            )
            impact_bins = curve.get_impact(intensity_bins)
            path = hazard_data[0].path

        else:
            assert isinstance(hazard_data[0], HazardParameterDataResponse)
            path = hazard_data[0].path
            indicators = np.concatenate(
                [
                    cast(HazardParameterDataResponse, response).parameters
                    for response in hazard_data
                ]
            )
            if len(indicators) == 0:
                return EmptyImpactDistrib()

            if curve.curve_type == "indicator":
                assert len(indicators) == 1
                probability_bins = np.array([1.0])
                impact_bins = curve.get_impact(indicators)
            else:
                exceedance_probabilities = indicators / to_year_fraction_divisor(
                    curve.indicator_units
                )
                if hazard_data[0].path.startswith("fire/jupiter/v1/fire_probability_"):
                    # The annual probability of fire being within 100km the grid square, a scaling
                    # factor of 1/500 is applied to approximate a high resolution probability of fire.
                    # This is a temporary measure until higher resolution fire hazard data is available.
                    exceedance_probabilities /= 500.0
                probability_bins = (
                    exceedance_probabilities[:-1] - exceedance_probabilities[1:]
                )
                probability_bins = np.append(
                    probability_bins, exceedance_probabilities[-1]
                )
                thresholds = (
                    np.concatenate(
                        [
                            cast(HazardParameterDataResponse, response).param_defns
                            for response in hazard_data
                        ]
                    )
                    if self.thresholds is None
                    else self.thresholds
                )
                impact_bins = curve.get_impact(thresholds)

            impact_bins = np.append(impact_bins, impact_bins[-1])

        return ImpactDistrib(
            self.hazard_type, impact_bins, probability_bins, [path], self.impact_type
        )

    def __repr__(self) -> str:
        return (
            f"ConfigBasedVulnerabilityModel(hazard_class={self.hazard_type.__name__},"
            f"indicator_id='{self.indicator_id}',impact_type={self.impact_type})"
        )
