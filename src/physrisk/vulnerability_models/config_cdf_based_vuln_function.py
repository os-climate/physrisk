from typing import Optional, Protocol
from numba import njit
import numpy as np

from physrisk.kernel.vulnerability_model import checked_beta_distrib


class UncertainVulnerabilityFunction(Protocol):
    def prob_matrix_for_indicator_bins(self, haz_ind_bin_edges: np.ndarray): ...


class CDFBasedVulnerabilityFunction(UncertainVulnerabilityFunction):
    """In general the vulnerability curve specifies for each hazard intensity level a
    cumulative probability density function.
    More precisely:
    The hazard intensity values, :math:`x_i`, are given, :math:`i \in [1 \dots n]`.
    .. math:: F_i(y) = \mathbb{P}(Y \leq y|x_i)

    The CDF, :math:`F_i(y)`, is given for points :math:`y_j`, :math:`j \in [1 \dots m]`.
    .. math::
        F_{ij} = \mathbb{P}(Y \leq y_j|x_i)
        x = [x_1, x_2, \dots, x_n ]
        y = [y_1, y_2, \dots, y_m ]
        z = [[F_{11}, F_{12}, \dots, F_{1m}], [F_{21}, F_{12}, \dots, F_{2m}], \dots, [F_{n1}, F_{n2}, \dots, F_{nm}]]


    Two cases:
    1) Hazard intensity, :math:`x'` is known (i.e. a drawing from an event set)
    Here the CDF is interpolated from the CDFs bounding the :math:`x'`:

    .. math:: F_{x'}(y_j) = \frac{x_{k+1} - x'}{x_{k+1} - x_k} F_{kj} + \frac{x' - x_k}{x_{k+1} - x_k} F_{(k+1)j}

    2) Probability is known within a range :math:(a, b).
    Here the CDF within the interval is approximated by the CDF interpolated at the midpoint math:`x' = \frac{a + b}{2}`.
    """

    _default_impact_grid = np.array(
        [0, 0.01, 0.05, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]
    )

    __slots__ = "cdf", "impact", "haz_indicator", "kind"

    def __init__(
        self,
        x: np.ndarray,
        y: np.ndarray,
        z: Optional[np.ndarray] = None,
        kind: str = "deterministic",
        impact_grid: Optional[np.ndarray] = _default_impact_grid,
    ):
        """Initialise a CDF

        Args:
            x (np.ndarray): array_like, (`n`,).
                            Hazard indicator values.
            y (np.ndarray): array_like, (`m`,).
                            Impact values if kind is 'deterministic', (`n`, ).
                            Mean impact values if kind is 'beta' or 'trunc_gauss', (`n`, ).
                            Impact values for CDF specified in `z` if kind is 'cdf', (`m`, )
            z (Optional[np.ndarray]): array_like.
                            Standard deviation of impact values if `kind` is 'beta' or 'trunc_gauss',
                            (`n`, ).
                            If `kind` is `cdf` then `z[i, j]` is the probability that if
                            the hazard indicator value is given by `x[i]` the impact is
                            `<= y[j]`, (`n`, `m`).
            kind (str): 'deterministic', 'beta', 'trunc_gaussian', 'cdf'. Defaults to 'deterministic'.
            impact_grid (np.ndarray): array_like, (`m`,).
                            If kind is 'beta' or 'trunc_gauss', defines the impact values on which
                            the CDF is calculated, otherwise unused.
        """
        if x.ndim != 1 or y.ndim != 1:
            raise ValueError("`x` and `y` must be 1 dimensional.")
        if kind in ["deterministic", "beta", "trunc_gauss"]:
            if len(x) != len(y):
                raise ValueError(f"`x` and `y` must have same length in `{kind}` case.")
            if kind == "determinisitc":
                if z is not None:
                    raise ValueError(f"`z` value is not used in `{kind}` case.")
                self.haz_indicator = x.copy()
                self.impact = y.copy()
            else:
                assert z is not None
                assert impact_grid is not None
                self.haz_indicator = x.copy()
                self.impact = impact_grid
                self.cdf = self._cdf_from_stddev(y, z, impact_grid, kind=kind)

        if kind == "cdf":
            assert z is not None
            if z.ndim != 2 or z.shape[0] != len(x) or z.shape[1] != len(y):
                raise ValueError("`z` should be two dimensional with shape (`n`, `m`).")
            self.haz_indicator = x.copy()
            self.impact = y.copy()
            self.cdf = z

        self.kind = kind

    def prob_matrix_for_indicator_bins(self, haz_ind_bin_edges: np.ndarray):
        """Calculate probability that impacts fall in each impact bin for each
        hazard bin.

        Args:
            haz_ind_bin_edges (np.ndarray): Hazard indicator bin edges.

        Returns:
            np.ndarray: Probability array, p, such that p[i, j] is the probability that if
                hazard indicator falls in bin i then impact is in bin j.
        """
        bin_edge_cdfs = self.interpolate_cdfs(haz_ind_bin_edges)
        bin_centre_cdfs = (bin_edge_cdfs[0:-1, :] + bin_edge_cdfs[1:, :]) * 0.5
        prob_matrix = bin_centre_cdfs[:, 1:] - bin_centre_cdfs[:, 0:-1]
        return prob_matrix

    def interpolate_cdfs(self, haz_ind_values: np.ndarray) -> np.ndarray:
        """Returns cumulative probabilities for the impact values for the hazard indicator values provided.
        This is done by linearly interpolating between the cumulative probabilities of the 'pillar'
        hazard indicators in self.haz_indicator.

        Args:
            haz_ind_values (np.ndarray): Hazard indicator values.

        Returns:
            np.ndarray: Array with size (len(haz_ind_values), len(impact)), i.e. a matrix with the CDFs
                in the rows.
        """
        right = np.searchsorted(self.haz_indicator, haz_ind_values, side="left")
        extrap = right == len(self.haz_indicator)
        right[extrap] = right[extrap] - 1
        left = right - 1
        cdfs = (
            (
                (self.haz_indicator[right] - haz_ind_values) * self.cdf[left, :].T
                + (haz_ind_values - self.haz_indicator[left]) * self.cdf[right, :].T
            )
            / (self.haz_indicator[right] - self.haz_indicator[left])
        ).T
        cdfs[extrap, :] = self.cdf[len(self.haz_indicator) - 1, :]
        return cdfs

    def _cdf_from_stddev(
        self,
        impact_mean: np.ndarray,
        impact_stddev: np.ndarray,
        impact_grid: np.ndarray,
        kind: str,
    ):
        if kind == "beta":
            # this is done just once for curve
            cdfs = np.zeros(shape=(len(impact_mean), len(impact_grid)))
            for i, m, s in zip(range(len(impact_mean)), impact_mean, impact_stddev):
                cdfs[i, :] = checked_beta_distrib(m, s)(impact_grid)
            return cdfs
        else:
            # TODO add support for "truncated_gaussian"
            raise NotImplementedError()


@njit(cache=True)
def sample_from_cumulative_probs(
    values: np.ndarray, cum_probs: np.ndarray, uniforms: np.ndarray
):
    n = cum_probs.shape[0]
    nb_samples = uniforms.shape[1]
    assert uniforms.shape[0] == n
    samples = np.zeros(shape=(n, nb_samples))
    for i in range(n):
        samples[i, :] = np.interp(uniforms[i, :], cum_probs[i, :], values)
