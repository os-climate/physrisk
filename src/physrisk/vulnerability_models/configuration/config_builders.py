from pathlib import Path
from typing import List, Optional, Protocol
from fsspec import AbstractFileSystem
from fsspec.implementations.local import LocalFileSystem
import numpy as np
import pandas as pd

from physrisk.kernel.assets import Asset, RealEstateAsset
from physrisk.kernel.hazards import (
    CoastalInundation,
    PluvialInundation,
    RiverineInundation,
    Wind,
)
from physrisk.kernel.impact_distrib import ImpactType
from physrisk.vulnerability_models.config_based_impact_curves import (
    VulnerabilityConfigItem,
)


def vulnerability_onboarding_dir():
    """Path of the vulnerability on-boarding directory."""
    path = (
        Path(__file__).parents[4]
        / "docs"
        / "user_guide"
        / "vulnerability"
        / "vulnerability_functions"
    )
    return path


def vulnerability_config_dir():
    """Path of the vulnerability configuration directory."""
    path = Path(__file__).parents[2] / "data" / "static" / "vulnerability"
    return path


class ConfigBuilder(Protocol):
    def build_config(self) -> List[VulnerabilityConfigItem]: ...


class ConfigBuilderBase:
    def __init__(
        self, source_dir: Optional[Path] = None, fs: Optional[AbstractFileSystem] = None
    ):
        """Instantiate base class for configuration builder.

        Args:
            source_dir (str): Full path to directory containing any source files.
                Defaults to None, in which case the default on-boarding directory in the
                repo is used.
            fs (Optional[AbstractFileSystem], optional): Instance of AbstractFileSystem to use to
                access source_dir e.g. S3FileSystem.
                Defaults to None, in which case a LocalFileSystem is assumed.
        """
        self.fs = fs if fs is not None else LocalFileSystem()
        self.source_dir = (
            source_dir if source_dir is not None else vulnerability_onboarding_dir()
        )


class ConfigBuilderJRCFlood(ConfigBuilderBase, ConfigBuilder):
    def build_config(self) -> List[VulnerabilityConfigItem]:
        """Create vulnerability config for flood based on the EU JRC global depth-damage functions.
        This replaces the notebook implementation and sets the pattern for code-based generation of the config.
        """

        # raw data is actually a reformatting of the original Excel spreadsheet to facilitate loading.
        raw_data = self.source_dir / "inundation_jrc" / "raw.csv"
        df = pd.read_csv(raw_data)

        # consistent with physrisk continent definition
        location_mappings = {
            "Europe": "Europe",
            "North America": "North America",
            "Central & South America": "South America",
            "Asia": "Asia",
            "Africa": "Africa",
            "Oceania": "Oceania",
            "Global": "Global",
        }
        type_mappings = {
            "Residential buildings": "Buildings/Residential",
            "Commercial buildings": "Buildings/Commercial",
            "Industrial buildings": "Buildings/Industrial",
        }

        config_items: List[VulnerabilityConfigItem] = []
        for mapping in type_mappings:
            type_df = df[df["Type"] == mapping]
            flood_depth = type_df["Flood depth [m]"].to_numpy()
            for location in location_mappings:
                # whether zero depth is considered really zero or a flood event with smallest depth
                zero_as_minimum = True if location == "North America" else False
                # for North America, the 0 depth damage is for flooding of any depth. We consider that a 1 cm inundation.
                depth = (
                    np.concatenate([[0, 0.01], flood_depth[1:]])
                    if zero_as_minimum
                    else flood_depth
                )

                mean = type_df[location + "_Mean"].to_numpy()
                std = type_df[location + "_Std"].to_numpy()
                mean = np.concatenate([[0], mean]) if zero_as_minimum else mean
                std = np.concatenate([[0], std]) if zero_as_minimum else std
                if np.any(np.isnan(mean)):
                    mean = []
                if np.any(np.isnan(std)):
                    std = []
                if not any(mean):
                    continue
                config_items.append(
                    VulnerabilityConfigItem(
                        hazard_class=",".join(
                            [
                                CoastalInundation.__name__,
                                PluvialInundation.__name__,
                                RiverineInundation.__name__,
                            ]
                        ),
                        asset_class=RealEstateAsset.__name__,
                        asset_identifier=f"type={type_mappings[mapping]},location={location_mappings[location]}",
                        indicator_id="flood_depth",
                        indicator_units="metres",
                        impact_id=str(ImpactType.damage.name),
                        curve_type="indicator/piecewise_linear",
                        points_x=list(depth),
                        points_y=list(np.round(mean, 3)),
                        # points_z=std, # omit for now: until implemented
                    )
                )
        return config_items


class ConfigBuilderEberenzWind(ConfigBuilderBase, ConfigBuilder):
    def build_config(self) -> List[VulnerabilityConfigItem]:
        """Create vulnerability config for generic wind assets based on
        Eberenz S, LÃ¼thi S, Bresch DN. Regional tropical cyclone impact functions
        for globally consistent risk assessments. Natural Hazards and Earth System Sciences.
        2021 Jan 29;21(1):393-415.
        """
        table_a2 = (
            self.source_dir / "wind_eberenz" / "Table_A2_Impact_Function_Slope.csv"
        )
        df = pd.read_csv(table_a2)
        v_half_lookup = (
            df[["region", "vhalf_b", "vhalf_c"]].set_index("region").to_dict()
        )
        v_half_north_america = (
            float(v_half_lookup["vhalf_b"]["NA2"])
            + float(v_half_lookup["vhalf_c"]["NA2"])
        ) / 2

        mapping = {
            "Asia": 74.7,
            "China Mainland": (
                float(v_half_lookup["vhalf_b"]["WP3"])
                + float(v_half_lookup["vhalf_c"]["WP3"])
            )
            / 2,
            "Europe": v_half_north_america,
            "Generic": v_half_north_america,
            "North America": v_half_north_america,
            "Oceania": (
                float(v_half_lookup["vhalf_b"]["OC"])
                + float(v_half_lookup["vhalf_c"]["OC"])
            )
            / 2,
            "South America": (
                float(v_half_lookup["vhalf_b"]["NA1"])
                + float(v_half_lookup["vhalf_c"]["NA1"])
            )
            / 2,
        }
        x = np.concat((np.arange(20.0, 55.0, 5.0), np.arange(60.0, 120.0, 10.0)))
        config_items: List[VulnerabilityConfigItem] = []
        for location, v_half in mapping.items():
            config_items.append(
                VulnerabilityConfigItem(
                    hazard_class=",".join([Wind.__name__]),
                    asset_class=Asset.__name__,
                    asset_identifier=f"type=Generic,location={location}",
                    indicator_id="max_speed",
                    indicator_units="m/s",
                    impact_id="damage",
                    curve_type="indicator/piecewise_linear",
                    points_x=list(x),
                    points_y=list(np.round(self.vulnerability(x, v_half), 3)),
                )
            )
        return config_items

    def vulnerability(self, v, v_half):
        v_thresh = 25.7
        # v_half = 135.6 # wp4 74.7 135.6 190.5
        vn = np.where(v > v_thresh, v - v_thresh, 0) / (v_half - v_thresh)
        f = vn**3 / (1 + vn**3)
        return f
