from collections import defaultdict
from dataclasses import dataclass
from enum import Enum
from functools import lru_cache
import sys
from typing import Any, NamedTuple, Optional, Protocol, Sequence

import numpy as np
import pandas as pd
from pydantic import BaseModel, ConfigDict, field_validator
from pydantic_core.core_schema import FieldValidationInfo

from physrisk.kernel.assets import Asset, OEDAsset
from physrisk.kernel.hazards import (
    CoastalInundation,
    Hazard,
    PluvialInundation,
    RiverineInundation,
)
from physrisk.vulnerability_models.config_based_impact_curves import (
    ImpactCurve,
    VulnerabilityConfigItem,
)


class VulnerabilityMapper(Protocol):
    """An instance of VulnerabilityMapper applies to hazards
    specified by hazard_types.

    For those hazards it infers the vulnerability config item.

    Args:
        Protocol (_type_): _description_
    """

    def hazard_types(self) -> list[type[Hazard]]: ...

    def map(
        self, asset: Asset, hazard_type: type[Hazard]
    ) -> VulnerabilityConfigItem: ...


class DamageType(str, Enum):
    STRUCTURE = "structure"
    CONTENTS = "contents"
    INVENTORY = "inventory"
    # downtime is excluded, as preferred model is to construct downtime
    # as a function of structural damage


def damage_type_list(value: Any):
    if isinstance(value, str):
        return [
            DamageType(x.lower())
            for x in value.replace("[", "").replace("]", "").split(",")
        ]
    return []


def float_list(value: Any):
    if isinstance(value, str):
        return [float(x) for x in value.replace("[", "").replace("]", "").split(",")]
    return []


def int_list(value: Any):
    if isinstance(value, str):
        return [
            int(x) if x != "" else None
            for x in value.replace("[", "").replace("]", "").split(",")
        ]
    return []


def str_list(value: Any):
    if isinstance(value, str):
        return [x for x in value.replace("[", "").replace("]", "").split(",")]
    return []


def range_list(value: Any):
    def range_from_str(s: str):
        split = s.split("-")
        return range(int(split[0]), int(split[1]) + 1)

    if isinstance(value, str):
        return [
            range_from_str(x)
            for x in value.replace("[", "").replace("]", "").split(",")
        ]
    return []


class OEDOccToHazusOcc(BaseModel):
    oed_occupancy_code: int
    oed_occupancy_name: str
    hazus_occupancy_codes: list[str]
    hazus_occupancy_code_weights: list[float]

    @field_validator("hazus_occupancy_codes", mode="before")
    @classmethod
    def convert_hazus_occupancy_codes(cls, value, info: FieldValidationInfo):
        return str_list(value)

    @field_validator("hazus_occupancy_code_weights", mode="before")
    @classmethod
    def convert_hazus_occupancy_code_weights(cls, value, info: FieldValidationInfo):
        return float_list(value)


class HazusOccToDamageFn(BaseModel):
    hazus_occupancy_code: str
    number_of_storeys_min: int
    number_of_storeys_max: int
    basement: int
    damage_type: list[DamageType]  # structure, contents or inventory
    damage_fn_id: list[Optional[str]]

    @field_validator("damage_type", mode="before")
    @classmethod
    def convert_damage_type(cls, value, info: FieldValidationInfo):
        return damage_type_list(value)

    @field_validator("damage_fn_id", mode="before")
    @classmethod
    def convert_damage_fn_id(cls, value, info: FieldValidationInfo):
        return str_list(value)


class HazusOccToSBT(BaseModel):
    model_config = ConfigDict(arbitrary_types_allowed=True)

    hazus_occupancy_code: str
    number_of_storeys_min: int
    number_of_storeys_max: int
    sbt_codes: list[str]
    construction_code_range: list[range]

    @field_validator("sbt_codes", mode="before")
    @classmethod
    def convert_sbt_codes(cls, value, info: FieldValidationInfo):
        return str_list(value)

    @field_validator("construction_code_range", mode="before")
    @classmethod
    def convert_sbt_code_weights(cls, value, info: FieldValidationInfo):
        return range_list(value)


class HazusOccDescription(BaseModel):
    hazus_occupancy_code: str
    source: str
    description: str


# @field_validator("*", mode="before")
# def use_default_value(cls, value, info: FieldValidationInfo):
#     if value is None:
#         raise PydanticUseDefault()
#     return value


@dataclass
class OEDMappingItem:
    hazus_occupancy_code: str
    basement: int
    number_of_storeys_min: int
    number_of_storeys_max: int
    construction_code_min: int
    construction_code_max: int
    damage_type: list[DamageType]  # structure, contents or inventory
    ids: list[str | None]


class OEDHazusMapper:
    def __init__(
        self,
        oed_occ_to_hazus_occ: list[OEDOccToHazusOcc],
        hazus_occ_to_damage_fn: list[HazusOccToDamageFn],
        hazus_occ_to_sbt: list[HazusOccToSBT],
        hazus_occ_description: list[HazusOccDescription],
        vulnerability_config_items: Sequence[VulnerabilityConfigItem],
    ):
        """Mapper from OED occupancy codes to Hazus-derived vulnerability config items.
        Items will be matched which have asset_identifiers of the form "hazus_fl_{damage_type}_dmg_id={damage_id}"
        and "hazus_ws_{damage_type}_dmg_id={damage_id}" ("fl" for flood, "ws" for wind-storm)
        where damage_type is one of ["structure", "contents", "inventory"], e.g.
        hazus_fl_structure_dmg_id=112".

        Args:
            oed_occ_to_hazus_occ (list[OEDOccToHazusOcc]): _description_
            hazus_occ_to_damage_fn (list[HazusOccToDamageFn]): _description_
            hazus_occ_to_sbt (list[HazusOccToSBT]): _description_
            vulnerability_config_items (list[VulnerabilityConfigItem]): vulnerability config items.
        """
        # for flood, get Hazus config
        vuln_config_flood: dict[tuple[DamageType, str], VulnerabilityConfigItem] = {}
        vuln_config_wind: dict[tuple[DamageType, str], VulnerabilityConfigItem] = {}
        for item in vulnerability_config_items:
            asset_ids = dict(
                key_value.split("=") for key_value in item.asset_identifier.split(",")
            )
            for damage_type in [
                DamageType.STRUCTURE,
                DamageType.CONTENTS,
                DamageType.INVENTORY,
            ]:
                key = f"hazus_fl_{damage_type.value}_dmg_id"
                if key in asset_ids:
                    vuln_config_flood[damage_type, asset_ids[key].strip()] = item
                key1, key2 = "hazus_wind_spec_build_type", "damage_type"
                if key1 in asset_ids and key2 in asset_ids:
                    if asset_ids[key2].strip().lower() == damage_type.value:
                        vuln_config_wind[damage_type, asset_ids[key1].strip()] = item

        self.oed_occ_to_hazus_occ_dict = {
            i.oed_occupancy_code: i for i in oed_occ_to_hazus_occ
        }
        self.lookup_flood = OEDMappingItemLookup(
            [
                OEDMappingItem(
                    i.hazus_occupancy_code,
                    i.basement,
                    i.number_of_storeys_min,
                    i.number_of_storeys_max,
                    1,
                    9999,
                    damage_type=i.damage_type,
                    ids=i.damage_fn_id,
                )
                for i in hazus_occ_to_damage_fn
            ],
            vuln_config_flood,
            {i.hazus_occupancy_code: i.description for i in hazus_occ_description},
        )
        # hazus_wind_spec_build_type=WSF1,damage_type=structure
        self.lookup_wind = OEDMappingItemLookup(
            [
                OEDMappingItem(
                    i.hazus_occupancy_code,
                    -1,
                    i.number_of_storeys_min,
                    i.number_of_storeys_max,
                    contr_code_range.start,
                    contr_code_range.stop - 1,
                    damage_type=[
                        DamageType.STRUCTURE,
                        DamageType.CONTENTS,
                        DamageType.INVENTORY,
                    ],
                    ids=[
                        sbt_code
                        for _ in [
                            DamageType.STRUCTURE,
                            DamageType.CONTENTS,
                            DamageType.INVENTORY,
                        ]
                    ],
                )
                for i in hazus_occ_to_sbt
                for sbt_code, contr_code_range in zip(
                    i.sbt_codes, i.construction_code_range
                )
            ],
            vuln_config_wind,
            {i.hazus_occupancy_code: i.description for i in hazus_occ_description},
        )
        # https://stackoverflow.com/questions/33672412/python-functools-lru-cache-with-instance-methods-release-object
        self._get_cached = lru_cache(maxsize=1000)(self._get)

    def hazard_types(self):
        return [RiverineInundation, CoastalInundation, PluvialInundation]

    def map(self, asset: OEDAsset, hazard_type: type[Hazard], explain: bool = False):
        hazard_family = (
            "flood"
            if hazard_type in [RiverineInundation, CoastalInundation, PluvialInundation]
            else "wind"
        )
        vuln_config, explanation = self._get_cached(
            asset.occupancy_code,
            asset.basement,
            self.special_storeys_to_storeys(asset.number_of_storeys),
            asset.construction_code,
            hazard_family,
            explain=explain,
        )
        if not vuln_config or not explanation:
            # no matches
            return None, MappingExplanation([]) if explain else None
        # for now assume 100% weight to structure, otherwise implement weighted average of curves here
        if DamageType.STRUCTURE not in vuln_config:
            return None, MappingExplanation(explanation) if explain else None
        config = vuln_config[DamageType.STRUCTURE]
        if hazard_family == "flood":
            return ImpactCurve.get_impact_curve_flood(
                config, first_floor_height=asset.first_floor_height
            ), MappingExplanation(explanation) if explain else None
        else:
            return ImpactCurve.get_impact_curve(config), MappingExplanation(
                explanation
            ) if explain else None

    def _get(
        self,
        oed_occupancy_code: int,
        basement: int,
        number_of_storeys: int,
        construction_code: int,
        hazard_family: str,
        explain: bool,
    ):
        occ_mapping = self.oed_occ_to_hazus_occ_dict.get(oed_occupancy_code)
        if occ_mapping is None:
            raise ValueError(f"Unknown OED occupancy code: {oed_occupancy_code}")

        look_up = (
            self.lookup_flood if hazard_family == "flood" else self.lookup_wind
        )  # extend for wind later
        if hazard_family == "wind":
            # for wind, basement is not used
            basement = -1
        vuln_items: list[dict[DamageType, VulnerabilityConfigItem | None]] = []
        explanations: list[ResolvedCurve | None] = []
        for i in occ_mapping.hazus_occupancy_codes:
            vuln_item, explanation = look_up.item_lookup(
                i, basement, number_of_storeys, construction_code, explain=explain
            )
            # if there is no match for number of storeys / construction code, skip
            if vuln_item:
                vuln_items.append(vuln_item)
                explanations.append(explanation)

        if len(vuln_items) == 0:
            # no matches
            return None, None
        if len(vuln_items) == 1:
            return vuln_items[0], explanations if explain else None
        return OEDHazusMapper._combined_curves(
            vuln_items, np.ones(len(vuln_items))
        ), explanations

    @staticmethod
    def _combined_curves(
        vuln_items: list[dict[DamageType, VulnerabilityConfigItem | None]],
        weights: np.ndarray,
    ):
        if len(vuln_items) == 1:
            return vuln_items[0]
        combined_vuln_items: dict[DamageType, VulnerabilityConfigItem | None] = {}
        for damage_type in [
            DamageType.STRUCTURE,
            DamageType.CONTENTS,
            DamageType.INVENTORY,
        ]:
            vuln_item_dt: list[VulnerabilityConfigItem] = [
                v[damage_type]  # type: ignore
                for v in vuln_items
                if v[damage_type] is not None
            ]
            if any(item.points_x != vuln_item_dt[0].points_x for item in vuln_item_dt):
                raise ValueError("Cannot combine curves with different x points")
            if len(vuln_item_dt) == 0:
                combined_vuln_items[damage_type] = None
                continue
            combined_y = sum(
                np.array(item.points_y) * w
                for item, w in zip(vuln_item_dt, weights.tolist())
            ) / len(vuln_items)
            combined_z = sum(
                np.array(item.points_z) * w
                for item, w in zip(vuln_item_dt, weights.tolist())
                if item.points_z
            ) / len(vuln_items)
            combined = vuln_item_dt[0].model_copy()
            combined.points_y = combined_y
            combined.points_z = combined_z
            combined_vuln_items[damage_type] = combined
        return combined_vuln_items

    def special_storeys_to_storeys(self, number_of_storeys: int) -> int:
        """Convert special number of storeys values to representative number of storeys.
        -1 = unknown number of storeys - low rise -> 2
        -2 = unknown number of storeys - mid rise -> 7
        -3 = Unknown number of storeys = high rise) -> 12

        Args:
            number_of_storeys (int): Number of storeys, possibly special value.

        Returns:
            int: Number of storeys.
        """
        if number_of_storeys == -1:
            return 2
        elif number_of_storeys == -2:
            return 7
        elif number_of_storeys == -3:
            return 12
        else:
            return number_of_storeys


class DiscretePropsKey(NamedTuple):
    oed_occupancy_code: str
    basement: int


@dataclass
class IntervalsConfig:
    number_of_storeys: pd.IntervalIndex
    construction_code: pd.IntervalIndex
    vulnerability_config: list[dict[DamageType, VulnerabilityConfigItem | None]]
    indices: np.ndarray


@dataclass
class ResolvedCurve:
    hazus_occupancy_code: str  # resolved occupancy code
    hazus_occupancy_description: str
    basement: bool  # resolved basement presence
    number_of_storeys: list[pd.Interval]  # resolved number of storeys
    construction_code: list[pd.Interval]  # resolved construction code
    resolved_ids: dict[DamageType, list[str]]

    def __str__(self):
        return f"Hazus occ code: {self.hazus_occupancy_code} ({self.hazus_occupancy_description}), basement: {self.basement}, storeys: {self.number_of_storeys}, construction codes: {self.construction_code}, resolved IDs: {self.resolved_ids}"


@dataclass
class MappingExplanation:
    resolved_curves: list[ResolvedCurve]

    def __str__(self):
        expl = (
            "Mapped to single Hazus occupancy code:\n"
            if len(self.resolved_curves) == 1
            else f"Averaging {len(self.resolved_curves)} Hazus occupancy codes:\n"
        )
        expl += "\n".join([str(curve) for curve in self.resolved_curves])
        return expl


class OEDMappingItemLookup:
    def __init__(
        self,
        oed_mapping_items: list[OEDMappingItem],
        vuln_config: dict[tuple[DamageType, str], VulnerabilityConfigItem],
        occupancy_description: dict[str, str],
    ):
        self._intervals: dict[DiscretePropsKey, IntervalsConfig] = (
            self._create_intervals(oed_mapping_items, vuln_config)
        )
        self._occupancy_description = occupancy_description

    def item_lookup(
        self,
        hazus_occupancy_code: str,
        basement_code: int,
        number_of_storeys: int,
        construction_code: int,
        explain: bool = False,
    ) -> tuple[dict[DamageType, VulnerabilityConfigItem | None], ResolvedCurve | None]:
        key = DiscretePropsKey(hazus_occupancy_code, basement_code)
        if key not in self._intervals:
            raise ValueError(
                f"No vulnerability configuration found for Hazus occupancy code {hazus_occupancy_code}, basement code {basement_code}"
            )
        intervals = self._intervals[key]

        storeys, constr_code = [], []
        try:
            storeys = intervals.indices[
                intervals.number_of_storeys.get_loc(number_of_storeys)
            ].tolist()
        except KeyError:
            # would be nice to have default instead
            storeys = []
        try:
            constr_code = intervals.indices[
                intervals.construction_code.get_loc(construction_code)
            ].tolist()
        except KeyError:
            constr_code = []
        hit_set = set(storeys if isinstance(storeys, list) else [storeys])
        if construction_code != 5000:  # unknown interpreted as 'accept all'
            hit_set = hit_set & set(
                constr_code if isinstance(constr_code, list) else [constr_code]
            )
        hits: list[int] = list(hit_set)
        hits = sorted(
            hits,
            key=lambda x: (
                intervals.number_of_storeys[x].length,
                intervals.construction_code[x].length,
            ),
        )
        if len(hits) == 0:
            return {}, None
        vuln_items = [intervals.vulnerability_config[hit] for hit in hits]
        combined = OEDHazusMapper._combined_curves(vuln_items, np.ones(len(vuln_items)))
        if explain:
            resolved_ids = defaultdict(list)
            for item in vuln_items:
                for dt, v in item.items():
                    if v is not None:
                        resolved_ids[dt].append(v.asset_identifier)
            expl = ResolvedCurve(
                hazus_occupancy_code=hazus_occupancy_code,
                hazus_occupancy_description=sys.intern(
                    self._occupancy_description.get(hazus_occupancy_code, "Unknown")
                ),
                basement=bool(basement_code),
                number_of_storeys=intervals.number_of_storeys[hits],
                construction_code=intervals.construction_code[hits],
                resolved_ids=resolved_ids,
            )
        else:
            expl = None
        return combined, expl

    def _create_intervals(
        self,
        items: list[OEDMappingItem],
        vuln_config: dict[tuple[DamageType, str], VulnerabilityConfigItem],
    ) -> dict[DiscretePropsKey, IntervalsConfig]:
        intervals_config: dict[DiscretePropsKey, IntervalsConfig] = {}
        grouped: dict[DiscretePropsKey, list[OEDMappingItem]] = defaultdict(list)
        for item in items:
            grouped[DiscretePropsKey(item.hazus_occupancy_code, item.basement)].append(
                item
            )
        for key in grouped:
            grouped_items = grouped[key]
            intervals_number_storeys = pd.IntervalIndex.from_tuples(
                [
                    (i.number_of_storeys_min, i.number_of_storeys_max)
                    for i in grouped_items
                ],
                closed="both",
            )
            intervals_construction_code = pd.IntervalIndex.from_tuples(
                [
                    (i.construction_code_min, i.construction_code_max)
                    for i in grouped_items
                ],
                closed="both",
            )
            config = [
                {
                    dt: (vuln_config.get((dt, id), None) if id is not None else None)
                    for dt, id in zip(i.damage_type, i.ids)
                }
                for i in grouped_items
            ]
            intervals_config[key] = IntervalsConfig(
                number_of_storeys=intervals_number_storeys,
                construction_code=intervals_construction_code,
                vulnerability_config=config,
                indices=np.array(range(len(grouped_items))),
            )

        return intervals_config
