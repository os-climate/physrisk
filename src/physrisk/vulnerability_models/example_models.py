from typing import Iterable

import numpy as np

from physrisk.kernel.assets import Asset
from physrisk.kernel.hazard_model import HazardDataRequest, HazardDataResponse
from physrisk.kernel.hazards import Fire

from ..kernel.impact_distrib import EmptyImpactDistrib, ImpactDistrib, ImpactType
from ..kernel.vulnerability_matrix_provider import VulnMatrixProvider
from ..kernel.vulnerability_model import VulnerabilityModel, VulnerabilityModelBase, checked_beta_distrib


class ExampleCdfBasedVulnerabilityModel(VulnerabilityModel):
    def __init__(self, *, indicator_id: str, hazard_type: type):
        self.intensities = np.array([0, 0.01, 0.5, 1.0, 1.5, 2, 3, 4, 5, 6])
        self.impact_means = np.array([0, 0.2, 0.44, 0.58, 0.68, 0.78, 0.85, 0.92, 0.96, 1.0])
        self.impact_stddevs = np.array([0, 0.17, 0.14, 0.14, 0.17, 0.14, 0.13, 0.10, 0.06, 0])
        impact_bin_edges = np.array([0, 0.01, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0])
        super().__init__(
            indicator_id=indicator_id,
            hazard_type=hazard_type,
            impact_type=ImpactType.damage,
            impact_bin_edges=impact_bin_edges,
        )

    def get_impact_curve(self, intensities, asset):
        # we interpolate the mean and standard deviation and use this to construct distributions
        impact_means = np.interp(intensities, self.intensities, self.impact_means)
        impact_stddevs = np.interp(intensities, self.intensities, self.impact_stddevs)
        return VulnMatrixProvider(
            intensities, impact_cdfs=[checked_beta_distrib(m, s) for m, s in zip(impact_means, impact_stddevs)]
        )


class PlaceholderVulnerabilityModel(VulnerabilityModelBase):
    """Placeholder vulnerability models are for when an impact or hazard indicator value
    is only intended to be used in a score-based risk measure.
    """

    def __init__(self, indicator_id: str, hazard_type: type, impact_type: ImpactType):
        super().__init__(indicator_id=indicator_id, hazard_type=hazard_type, impact_type=impact_type)

    def get_data_requests(self, asset: Asset, *, scenario: str, year: int):
        return HazardDataRequest(
            self.hazard_type,
            asset.longitude,
            asset.latitude,
            scenario=scenario,
            year=year,
            indicator_id=self.indicator_id,
        )

    def get_impact(self, asset: Asset, data_responses: Iterable[HazardDataResponse]) -> ImpactDistrib:
        return EmptyImpactDistrib()


class PlaceholderFireModel(PlaceholderVulnerabilityModel):
    def __init__(self):
        """This model has two functions:
        1) Demonstrate how a wildfire model can be added in such a way that it combines as expected
        with other acute and chronic risks.
        2) Provide a vulnerability function that can supply a reference impact distribution.
        This can be used with score-based measures.

        The hazard indicator used is annual probability of wildfire. This is the probability that
        in a year there is a wildfire such that the wildfire zone includes the asset location.
        'Wildfire' is taken to be a major fire event, one with the potential to damage or disrupt the asset.
        Wildfire zone refers to the affected area, i.e. into which the wildfire propagates.

        Typically fire models are calculated using a certain pixel size and provide the probability that
        the wildfire propagates into the pixel containing the asset. For large pixel sizes, clearly this is
        not the same as the probability that the asset is within the wildfire zone.
        """
        ...

        super().__init__(
            indicator_id="fire_probability",
            hazard_type=Fire,
            impact_type=ImpactType.damage,
        )

    def get_impact(self, asset: Asset, data_responses: Iterable[HazardDataResponse]) -> ImpactDistrib:
        # params = data_responses
        # assert isinstance(data_response, HazardParameterDataResponse)
        # TODO add model with stochastic impact
        return EmptyImpactDistrib()
