# selects impact curve based on asset properties

import collections
from dataclasses import dataclass
from importlib import import_module
from importlib.resources import files
from typing import NamedTuple, Protocol, Sequence

import pandas as pd
import physrisk.data.static.vulnerability.oed_hazus
import physrisk.kernel.assets
from physrisk.kernel.assets import Asset, OEDAsset
from physrisk.kernel.hazards import (
    CoastalInundation,
    Hazard,
    PluvialInundation,
    RiverineInundation,
    Wind,
)
from physrisk.kernel.impact_distrib import ImpactType
from physrisk.vulnerability_models.config_based_impact_curves import (
    ImpactCurve,
    ImpactCurveKey,
    ParametricImpactCurve,
    PiecewiseLinearImpactCurve,
    VulnerabilityConfigItem,
)
from physrisk.vulnerability_models.config_cdf_based_vuln_function import (
    CDFBasedVulnerabilityFunction,
)
from physrisk.vulnerability_models.configuration.oed_mapping import (
    HazusOccDescription,
    HazusOccToDamageFn,
    HazusOccToSBT,
    OEDHazusMapper,
    OEDOccToHazusOcc,
)


class ImpactFunctionSelectorOld(Protocol):
    """Selects a vulnerability function based on asset properties. Instances are used, for example, within
    vulnerability models."""

    def select(
        self, asset: Asset
    ) -> (
        ParametricImpactCurve
        | PiecewiseLinearImpactCurve
        | CDFBasedVulnerabilityFunction
        | None
    ): ...


class ImpactFunctionSelector(Protocol):
    """Selects a vulnerability function based on asset properties. Instances are used, for example, within
    vulnerability models."""

    def select(
        self,
        asset: Asset,
        hazard_type: type[Hazard],
        indicator_id: str,
        impact_type: ImpactType,
    ) -> (
        ParametricImpactCurve
        | PiecewiseLinearImpactCurve
        | CDFBasedVulnerabilityFunction
        | None
    ): ...


class VulnModelKey(NamedTuple):
    asset_type: type[Asset]
    hazard_type: type[Hazard]
    indicator_id: str
    impact_type: ImpactType


@dataclass
class GroupLookup:
    """Contains a group of impact functions, and also the set of attributes (asset_attributes) needed to
    match. These are either direct attributes of an Asset instance or inferred from these.
    """

    asset_attributes: set[str]
    impact_functions: dict[
        ImpactCurveKey,
        ParametricImpactCurve
        | PiecewiseLinearImpactCurve
        | CDFBasedVulnerabilityFunction,
    ]


class ConfigBasedImpactFunctionSelector(ImpactFunctionSelector):
    def __init__(self, config_items: Sequence[VulnerabilityConfigItem]):
        physrisk_assets = import_module("physrisk.kernel.assets")
        physrisk_hazards = import_module("physrisk.kernel.hazards")
        grouped_items: dict[VulnModelKey, list[VulnerabilityConfigItem]] = (
            collections.defaultdict(list)
        )
        self._groups: dict[VulnModelKey, GroupLookup] = {}

        for item in config_items:
            asset_type = getattr(physrisk_assets, item.asset_class)
            hazard_type = getattr(physrisk_hazards, item.hazard_class)
            impact_type = (
                ImpactType.damage
                if item.impact_id == "damage"
                else ImpactType.disruption
            )
            grouped_items[
                VulnModelKey(
                    asset_type,
                    hazard_type,
                    self._get_indicator_id(item.indicator_id),
                    impact_type,
                )
            ].append(item)

        for key, values in grouped_items.items():
            impact_functions = {
                ImpactCurveKey(item.asset_identifier): ImpactCurve.get_impact_curve(
                    item
                )
                for item in values
            }
            lookup = GroupLookup(
                impact_functions=impact_functions,
                asset_attributes=set(
                    key for curve in impact_functions for key in curve.identifier.keys()
                ),
            )
            self._groups[key] = lookup

        # deal with ancestors: the ancestors of each asset class are identified at this point, so that if
        # a match is not found with the class itself an ancestor match can be attempted.
        all_asset_types = physrisk.kernel.assets.all_asset_types()
        all_asset_types.add(Asset)
        # set(k.asset_type for k in self._groups.keys())

        # consider excluding OEDAsset
        self._ancestors = {
            t: [a for a in t.mro() if a not in [t, object]] for t in all_asset_types
        }

    def _get_indicator_id(self, indicator_id: str) -> str:
        if any(
            indicator_id.startswith(prefix) for prefix in ["flood_depth", "max_speed"]
        ):
            return indicator_id.split("/")[0]
        return indicator_id

    def keys(self):
        """The keys for which one or more configuration items exist."""
        return self._groups.keys()

    def select(
        self,
        asset: Asset,
        hazard_type: type[Hazard],
        indicator_id: str,
        impact_type: ImpactType,
    ):
        asset_types = [type(asset)] + self._ancestors[type(asset)]
        for asset_type in asset_types:
            # try to resolve first using config specific to the asset type, e.g. RealEstateAsset
            # if unsuccessful, try ancestors, e.g. config defined against Asset
            key = VulnModelKey(
                asset_type,
                hazard_type,
                self._get_indicator_id(indicator_id),
                impact_type,
            )
            if key not in self._groups:
                continue
            group = self._groups[key]
            resolved_key = ImpactCurveKey.get(
                asset, group.asset_attributes, group.impact_functions.keys()
            )
            if resolved_key:
                return group.impact_functions[resolved_key]
        return None


class OEDHazusImpactFunctionSelector(ImpactFunctionSelector):
    def __init__(self, config_items: Sequence[VulnerabilityConfigItem]):
        """The selector will first

        Args:
            oed_mapper (OEDHazusMapper): _description_
            vulnerability_config_items (Sequence[VulnerabilityConfigItem]): _description_
        """

        # load oed_occ_to_hazus_occ from file
        oed_hazus_files = files(physrisk.data.static.vulnerability.oed_hazus)

        df = pd.read_csv(oed_hazus_files.joinpath("oed_occ_to_hazus_occ.csv"))
        oed_occ_to_hazus_occ_items = list(
            df.apply(lambda row: OEDOccToHazusOcc(**row), axis=1)
        )

        df = pd.read_csv(oed_hazus_files.joinpath("hazus_occ_to_damage_fn.csv"))
        hazus_occ_to_damage_fn_items = list(
            df.apply(lambda row: HazusOccToDamageFn(**row), axis=1)
        )

        df = pd.read_csv(oed_hazus_files.joinpath("occ_to_sbt.csv"))
        hazus_occ_to_sbt_items = list(
            df.apply(lambda row: HazusOccToSBT(**row), axis=1)
        )

        df = pd.read_csv(oed_hazus_files.joinpath("hazus_occ_desc.csv"))
        hazus_occ_desc_items = list(
            df.apply(lambda row: HazusOccDescription(**row), axis=1)
        )

        self.oed_mapper = OEDHazusMapper(
            oed_occ_to_hazus_occ=oed_occ_to_hazus_occ_items,
            hazus_occ_to_damage_fn=hazus_occ_to_damage_fn_items,
            hazus_occ_to_sbt=hazus_occ_to_sbt_items,
            hazus_occ_description=hazus_occ_desc_items,
            vulnerability_config_items=config_items,
        )
        self.vulnerability_config_items = config_items

    def select(
        self,
        asset: Asset,
        hazard_type: type[Hazard],
        indicator_id: str,
        impact_type: ImpactType,
    ):
        """Selects an impact function for the given asset.

        Args:
            asset (Asset): The asset for which to select the impact function.

        Returns:
            ParametricImpactCurve | PiecewiseLinearImpactCurve | CDFBasedVulnerabilityFunction: The selected impact function.
        """
        if impact_type != ImpactType.damage:
            # disruption separately is inferred from damage
            raise NotImplementedError(
                f"OED-Hazus mapping only supports 'damage' impact type for wind hazard, got '{impact_type}'"
            )
        if hazard_type in [CoastalInundation, PluvialInundation, RiverineInundation]:
            if indicator_id != "flood_depth":
                raise NotImplementedError(
                    f"OED-Hazus mapping only supports 'flood_depth' indicator for inundation hazards, got '{indicator_id}'"
                )
        elif hazard_type == Wind:
            if indicator_id != "max_speed":
                raise NotImplementedError(
                    f"OED-Hazus mapping only supports 'max_speed' indicator for wind hazard, got '{indicator_id}'"
                )

        if not isinstance(asset, OEDAsset):
            raise TypeError(
                f"OED-Hazus mapping only supports assets of type 'Asset', got '{type(asset)}'"
            )
        impact_function, _ = self.oed_mapper.map(asset, hazard_type)
        # consider logging the explanation (/ exposing via service)
        return impact_function


class CombinedImpactFunctionSelector(ImpactFunctionSelector):
    def __init__(
        self,
        oed_hazus_selector: OEDHazusImpactFunctionSelector,
        config_based_selector: ConfigBasedImpactFunctionSelector,
    ):
        self.oed_hazus_selector = oed_hazus_selector
        self.config_based_selector = config_based_selector

    def select(
        self,
        asset: Asset,
        hazard_type: type[Hazard],
        indicator_id: str,
        impact_type: ImpactType,
    ):
        result = self.oed_hazus_selector.select(
            asset, hazard_type, indicator_id, impact_type
        )
        if result is None:
            return self.config_based_selector.select(
                asset, hazard_type, indicator_id, impact_type
            )
        return result
