from collections import defaultdict
from typing import Iterable, List, Tuple, Union

import numpy as np

from physrisk.api.v1.common import VulnerabilityCurve, VulnerabilityCurves
from physrisk.data.hazard_data_provider import HazardDataBufferZone
from physrisk.kernel.assets import Asset, ThermalPowerGeneratingAsset, TurbineKind
from physrisk.kernel.impact_distrib import ImpactType
from physrisk.kernel.vulnerability_matrix_provider import VulnMatrixProvider
from physrisk.kernel.vulnerability_model import VulnerabilityModel

from ..kernel.curve import ExceedanceCurve
from ..kernel.hazard_event_distrib import HazardEventDistrib
from ..kernel.hazard_model import HazardDataRequest, HazardDataResponse, HazardEventDataResponse
from ..kernel.hazards import CoastalInundation, RiverineInundation
from ..kernel.vulnerability_distrib import VulnerabilityDistrib
from ..kernel.vulnerability_model import (
    applies_to_assets,
    applies_to_events,
    cdf_max_of,
    cdf_weighted_sum,
    checked_beta_distrib,
    get_vulnerability_curves_from_resource,
)


class ThermalPowerGenerationInundationModel(VulnerabilityModel):
    # Number of disrupted days per year
    _default_impact_bin_edges = np.array([0, 1, 2, 7, 14, 30, 60, 180, 365])
    _default_resource = "WRI thermal power plant physical climate vulnerability factors"
    _default_buffer_zone = HazardDataBufferZone(delta_deg=0.01, n_grid=5)

    def __init__(
        self,
        *,
        hazard_type: type,
        indicator_id: str,
        resource: str = _default_resource,
        impact_bin_edges=_default_impact_bin_edges,
        buffer_zone=_default_buffer_zone
    ):
        """
        Inundation vulnerability model for thermal power generation.
        Applies to both riverine and coastal inundation.

        Args:
            event_type: Event type.
            model: optional identifier for hazard event model, passed to HazardModel.
            resource: embedded resource identifier used to infer vulnerability matrix.
            impact_bin_edges: specifies the impact (fractional damage/disruption bins).
        """

        curve_set: VulnerabilityCurves = get_vulnerability_curves_from_resource(resource)

        # for this model, key for looking up curves is asset_type, e.g. 'steam/recirculating'
        self.vulnerability_curves = dict(
            (c.asset_type.lower(), c) for c in curve_set.items if c.event_type == hazard_type.__base__.__name__.lower()
        )
        self.vuln_curves_by_type = defaultdict(list)
        for key in self.vulnerability_curves:
            self.vuln_curves_by_type[TurbineKind[key.split("/")[0].lower()]].append(self.vulnerability_curves[key])

        impact_type = (
            ImpactType.disruption
            if len(self.vulnerability_curves) == 0
            else [ImpactType[self.vulnerability_curves[key].impact_type.lower()] for key in self.vulnerability_curves][
                0
            ]
        )

        # global circulation parameter 'model' is a hint; can be overriden by hazard model
        super().__init__(
            indicator_id=indicator_id,
            hazard_type=hazard_type,
            impact_type=impact_type,
            impact_bin_edges=impact_bin_edges,
            buffer_zone=buffer_zone,
        )

    def get_data_requests(
        self, asset: Asset, *, scenario: str, year: int
    ) -> Union[HazardDataRequest, Iterable[HazardDataRequest]]:
        """Provide the list of hazard event data requests required in order to calculate
        the VulnerabilityDistrib and HazardEventDistrib for the asset."""
        request_scenario = HazardDataRequest(
            self.hazard_type,
            asset.longitude,
            asset.latitude,
            scenario=scenario,
            year=year,
            indicator_id=self.indicator_id,
            buffer_zone=self.buffer_zone,
        )
        request_baseline = HazardDataRequest(
            self.hazard_type,
            asset.longitude,
            asset.latitude,
            scenario="historical",
            year=1980,
            indicator_id=self.indicator_id,
            buffer_zone=self.buffer_zone,
        )
        return request_scenario, request_baseline

    def get_impact_curve(self, intensity_bins: np.ndarray, asset: Asset):
        assert isinstance(asset, ThermalPowerGeneratingAsset)

        curves: List[VulnerabilityCurve] = []
        if asset.turbine is None:
            curves = [self.vulnerability_curves[key] for key in self.vulnerability_curves]
        elif asset.cooling is not None:
            key = "/".join([str(asset.turbine), str(asset.cooling)])
            if key in self.vulnerability_curves:
                curves = [self.vulnerability_curves[key]]
        elif asset.turbine in self.vuln_curves_by_type:
            curves = self.vuln_curves_by_type[asset.turbine]

        if len(curves) == 0:
            return VulnMatrixProvider(
                intensity_bins, impact_cdfs=[checked_beta_distrib(0.0, 0.0) for _ in intensity_bins]
            )

        scaling_factor = self.impact_bin_edges[-1]
        interpolation_schemes = [
            np.transpose(
                [
                    np.interp(
                        intensity_bins,
                        curve.intensity,
                        [1.0 if i == j else 0.0 for j, _ in enumerate(curve.intensity)],
                    )
                    for i, _ in enumerate(curve.intensity)
                ]
            )
            for curve in curves
        ]
        impact_cdfs = [
            [
                checked_beta_distrib(mean, 0.0 if len(curve.impact_std) == 0 else curve.impact_std[i], scaling_factor)
                for i, mean in enumerate(curve.impact_mean)
            ]
            for curve in curves
        ]
        impact_cdfs = [
            [cdf_weighted_sum(weights, impact_cdf) for weights in interpolation_scheme]
            for interpolation_scheme, impact_cdf in zip(interpolation_schemes, impact_cdfs)
        ]
        impact_cdfs = [cdf_max_of(cdfs) for cdfs in np.transpose(impact_cdfs)]

        return VulnMatrixProvider(intensity_bins, impact_cdfs=list(np.array(impact_cdfs)))

    def get_distributions(
        self, asset: Asset, event_data_responses: Iterable[HazardDataResponse]
    ) -> Tuple[VulnerabilityDistrib, HazardEventDistrib]:
        assert isinstance(asset, ThermalPowerGeneratingAsset)

        (response_scenario, response_baseline) = event_data_responses
        assert isinstance(response_scenario, HazardEventDataResponse)
        assert isinstance(response_baseline, HazardEventDataResponse)

        baseline_curve = ExceedanceCurve(1.0 / response_baseline.return_periods, response_baseline.intensities)
        inundation_protection_level = (
            0.0
            if len(response_baseline.intensities) == 0
            else baseline_curve.get_value(1.0 / asset.get_inundation_protection_return_period())
        )

        intensity_curve = ExceedanceCurve(1.0 / response_scenario.return_periods, response_scenario.intensities)
        if intensity_curve.values[0] < inundation_protection_level:
            if inundation_protection_level < intensity_curve.values[-1]:
                intensity_curve = intensity_curve.add_value_point(inundation_protection_level)

        intensity_bin_edges, probs = intensity_curve.get_probability_bins()
        probability_transition_matrix = self.get_impact_curve(intensity_bin_edges, asset).to_cdf_matrix(
            self.impact_bin_edges
        )
        probability_transition_matrix[:, 1:] -= probability_transition_matrix[:, :-1]
        inundation_protection_matrix = np.diag(np.where(intensity_bin_edges <= inundation_protection_level, 0.0, 1.0))
        probability_transition_matrix = np.matmul(inundation_protection_matrix, probability_transition_matrix)

        vul = VulnerabilityDistrib(
            self.hazard_type, intensity_bin_edges, self.impact_bin_edges, probability_transition_matrix
        )
        probs = np.insert(probs, 0, intensity_curve.probs[0])
        probs[-1] += 1.0 - np.sum(probs)
        event = HazardEventDistrib(self.hazard_type, intensity_bin_edges, probs)

        return vul, event


@applies_to_events([CoastalInundation])
@applies_to_assets([ThermalPowerGeneratingAsset])
class ThermalPowerGenerationCoastalInundationModel(ThermalPowerGenerationInundationModel):
    def __init__(
        self,
        *,
        indicator_id: str = "flood_depth",
        resource: str = ThermalPowerGenerationInundationModel._default_resource,
        impact_bin_edges=ThermalPowerGenerationInundationModel._default_impact_bin_edges
    ):
        # by default include subsidence and 95% sea-level rise
        super().__init__(
            hazard_type=CoastalInundation,
            indicator_id=indicator_id,
            resource=resource,
            impact_bin_edges=impact_bin_edges,
        )


@applies_to_events([RiverineInundation])
@applies_to_assets([ThermalPowerGeneratingAsset])
class ThermalPowerGenerationRiverineInundationModel(ThermalPowerGenerationInundationModel):
    def __init__(
        self,
        *,
        indicator_id: str = "flood_depth",
        resource: str = ThermalPowerGenerationInundationModel._default_resource,
        impact_bin_edges=ThermalPowerGenerationInundationModel._default_impact_bin_edges
    ):
        # by default request HazardModel to use "MIROC-ESM-CHEM" GCM
        super().__init__(
            hazard_type=RiverineInundation,
            indicator_id=indicator_id,
            resource=resource,
            impact_bin_edges=impact_bin_edges,
        )
