from collections import defaultdict
from typing import Iterable, List, Tuple, Union, cast

import numpy as np
from scipy.stats import norm

from physrisk.api.v1.common import VulnerabilityCurve, VulnerabilityCurves
from physrisk.kernel.assets import Asset, ThermalPowerGeneratingAsset, TurbineKind
from physrisk.kernel.impact_distrib import ImpactDistrib, ImpactType
from physrisk.kernel.vulnerability_model import DeterministicVulnerabilityModel, VulnerabilityModelBase

from ..kernel.curve import ExceedanceCurve
from ..kernel.hazard_event_distrib import HazardEventDistrib
from ..kernel.hazard_model import (
    HazardDataRequest,
    HazardDataResponse,
    HazardEventDataResponse,
    HazardParameterDataResponse,
)
from ..kernel.hazards import ChronicHeat, CoastalInundation, Drought, RiverineInundation
from ..kernel.vulnerability_distrib import VulnerabilityDistrib
from ..kernel.vulnerability_model import applies_to_assets, applies_to_events, get_vulnerability_curves_from_resource


class ThermalPowerGenerationInundationModel(DeterministicVulnerabilityModel):
    # Number of disrupted days per year
    _default_resource = "WRI thermal power plant physical climate vulnerability factors"

    # delimitation of the area for the hazard data expressed in metres (within [0,1000]).
    _default_buffer = 1000

    def __init__(
        self, *, hazard_type: type, indicator_id: str, resource: str = _default_resource, buffer: int = _default_buffer
    ):
        """
        Inundation vulnerability model for thermal power generation.
        Applies to both riverine and coastal inundation.

        Args:
                hazard_type (type): _description_
                indicator_id (str): ID of the hazard indicator to which this applies.
                resource (str): embedded resource identifier used to infer vulnerability table.
                buffer (int): delimitation of the area for the hazard data expressed in metres (within [0,1000]).
        """

        curve_set: VulnerabilityCurves = get_vulnerability_curves_from_resource(resource)

        # for this model, key for looking up curves is asset_type, e.g. 'Steam/Recirculating'
        self.vulnerability_curves = dict(
            (c.asset_type, c) for c in curve_set.items if c.event_type == hazard_type.__base__.__name__  # type:ignore
        )
        self.vuln_curves_by_type = defaultdict(list)
        for key in self.vulnerability_curves:
            self.vuln_curves_by_type[TurbineKind[key.split("/")[0]]].append(self.vulnerability_curves[key])

        impact_type = (
            ImpactType.disruption
            if len(self.vulnerability_curves) == 0
            else [ImpactType[self.vulnerability_curves[key].impact_type.lower()] for key in self.vulnerability_curves][
                0
            ]
        )

        # global circulation parameter 'model' is a hint; can be overriden by hazard model
        super().__init__(
            indicator_id=indicator_id,
            hazard_type=hazard_type,
            impact_type=impact_type,
            damage_curve_intensities=[],
            damage_curve_impacts=[],
            buffer=buffer,
        )

    def get_data_requests(
        self, asset: Asset, *, scenario: str, year: int
    ) -> Union[HazardDataRequest, Iterable[HazardDataRequest]]:
        """Provide the list of hazard event data requests required in order to calculate
        the VulnerabilityDistrib and HazardEventDistrib for the asset."""
        request_scenario = HazardDataRequest(
            self.hazard_type,
            asset.longitude,
            asset.latitude,
            scenario=scenario,
            year=year,
            indicator_id=self.indicator_id,
            buffer=self.buffer,
        )
        request_baseline = HazardDataRequest(
            self.hazard_type,
            asset.longitude,
            asset.latitude,
            scenario=scenario,
            year=2030,
            indicator_id=self.indicator_id,
            buffer=self.buffer,
        )
        return request_scenario, request_baseline

    def get_distributions(
        self, asset: Asset, event_data_responses: Iterable[HazardDataResponse]
    ) -> Tuple[VulnerabilityDistrib, HazardEventDistrib]:
        assert isinstance(asset, ThermalPowerGeneratingAsset)

        (response_scenario, response_baseline) = event_data_responses
        assert isinstance(response_scenario, HazardEventDataResponse)
        assert isinstance(response_baseline, HazardEventDataResponse)

        baseline_curve = ExceedanceCurve(1.0 / response_baseline.return_periods, response_baseline.intensities)
        protection_depth = (
            0.0
            if len(response_baseline.intensities) == 0
            else baseline_curve.get_value(1.0 / asset.get_inundation_protection_return_period())
        )

        intensity_curve = ExceedanceCurve(1.0 / response_scenario.return_periods, response_scenario.intensities)
        if 0 < len(intensity_curve.values):
            if intensity_curve.values[0] < protection_depth:
                if protection_depth < intensity_curve.values[-1]:
                    intensity_curve = intensity_curve.add_value_point(protection_depth)

        intensities, probs = intensity_curve.get_probability_bins()
        if 0 < len(intensity_curve.values):
            probs = np.insert(probs, 0, intensity_curve.probs[0])

        curves: List[VulnerabilityCurve] = []
        if asset.turbine is None:
            curves = [self.vulnerability_curves[key] for key in self.vulnerability_curves]
        elif asset.cooling is not None:
            key = "/".join([str(asset.turbine), str(asset.cooling)])
            if key in self.vulnerability_curves:
                curves = [self.vulnerability_curves[key]]
        elif asset.turbine in self.vuln_curves_by_type:
            curves = self.vuln_curves_by_type[asset.turbine]

        if 0 < len(curves):
            impacts = [
                (
                    np.max([np.interp(intensity, curve.intensity, curve.impact_mean) for curve in curves]) / 365.0
                    if protection_depth < intensity
                    else 0.0
                )
                for intensity in intensities
            ]
        else:
            impacts = [0.0 for _ in intensities]

        vul = VulnerabilityDistrib(self.hazard_type, intensities, impacts, np.eye(len(probs), len(probs)))
        event = HazardEventDistrib(self.hazard_type, intensities, probs)
        return vul, event


@applies_to_events([CoastalInundation])
@applies_to_assets([ThermalPowerGeneratingAsset])
class ThermalPowerGenerationCoastalInundationModel(ThermalPowerGenerationInundationModel):
    def __init__(
        self,
        *,
        indicator_id: str = "flood_depth",
        resource: str = ThermalPowerGenerationInundationModel._default_resource
    ):
        # by default include subsidence and 95% sea-level rise
        super().__init__(hazard_type=CoastalInundation, indicator_id=indicator_id, resource=resource)


@applies_to_events([RiverineInundation])
@applies_to_assets([ThermalPowerGeneratingAsset])
class ThermalPowerGenerationRiverineInundationModel(ThermalPowerGenerationInundationModel):
    def __init__(
        self,
        *,
        indicator_id: str = "flood_depth",
        resource: str = ThermalPowerGenerationInundationModel._default_resource
    ):
        # by default request HazardModel to use "MIROC-ESM-CHEM" GCM
        super().__init__(hazard_type=RiverineInundation, indicator_id=indicator_id, resource=resource)


@applies_to_events([Drought])
@applies_to_assets([ThermalPowerGeneratingAsset])
class ThermalPowerGenerationDroughtModel(VulnerabilityModelBase):
    # Number of disrupted days per year
    _default_resource = "WRI thermal power plant physical climate vulnerability factors"

    def __init__(self, *, resource: str = _default_resource):
        """
        Drought vulnerability model for thermal power generation.

        Args:
                resource (str): embedded resource identifier used to infer vulnerability table.
        """

        hazard_type = Drought
        curve_set: VulnerabilityCurves = get_vulnerability_curves_from_resource(resource)

        # for this model, key for looking up curves is asset_type, e.g. 'Steam/Recirculating'
        self.vulnerability_curves = dict(
            (c.asset_type, c) for c in curve_set.items if c.event_type == hazard_type.__name__
        )

        denominator = norm.cdf(-2.0)
        self.impact_by_asset_type = defaultdict(list)
        for key in self.vulnerability_curves:
            probabilities = np.array(
                [norm.cdf(intensity) / denominator for intensity in self.vulnerability_curves[key].intensity]
            )
            probabilities[:-1] -= probabilities[1:]
            self.impact_by_asset_type[key] = sum(
                [
                    probability * impact
                    for probability, impact in zip(probabilities, self.vulnerability_curves[key].impact_mean)
                ]
            )

        self.impact_by_type = defaultdict(list)
        self.vuln_curves_by_type = defaultdict(list)
        for key in self.vulnerability_curves:
            turbine_kind = TurbineKind[key.split("/")[0]]
            self.impact_by_type[turbine_kind].append(self.impact_by_asset_type[key])
            self.vuln_curves_by_type[turbine_kind].append(self.vulnerability_curves[key])

        impact_type = (
            ImpactType.disruption
            if len(self.vulnerability_curves) == 0
            else [ImpactType[self.vulnerability_curves[key].impact_type.lower()] for key in self.vulnerability_curves][
                0
            ]
        )

        # global circulation parameter 'model' is a hint; can be overriden by hazard model
        super().__init__(indicator_id="months/spei3m/below/-2", hazard_type=hazard_type, impact_type=impact_type)

    def get_data_requests(
        self, asset: Asset, *, scenario: str, year: int
    ) -> Union[HazardDataRequest, Iterable[HazardDataRequest]]:
        return HazardDataRequest(
            self.hazard_type,
            asset.longitude,
            asset.latitude,
            scenario=scenario,
            year=year,
            indicator_id=self.indicator_id,
        )

    def get_impact(self, asset: Asset, data_responses: List[HazardDataResponse]) -> ImpactDistrib:
        assert isinstance(asset, ThermalPowerGeneratingAsset)

        # The unit being number of months per year, we divide by 12 to express the result as a year fraction.
        spei3m_below_minus_2 = cast(HazardParameterDataResponse, data_responses[0]).parameter / 12.0

        impact = 0.0
        if asset.turbine is None:
            impact = np.max([self.impact_by_asset_type[key] for key in self.impact_by_asset_type])
        elif asset.cooling is not None:
            key = "/".join([str(asset.turbine), str(asset.cooling)])
            if key in self.impact_by_asset_type:
                impact = self.impact_by_asset_type[key]
        elif asset.turbine in self.vuln_curves_by_type:
            impact = np.max(self.impact_by_type[asset.turbine])

        # The point injected at the beginning of impacts/intensities
        # allows to successfully call to_exceedance() as in API get_impact:
        impact_distrib = ImpactDistrib(
            self.hazard_type,
            np.array([0.0, impact]),
            np.array([1.0 - spei3m_below_minus_2, spei3m_below_minus_2]),
            self.impact_type,
        )
        return impact_distrib


@applies_to_events([ChronicHeat])
@applies_to_assets([ThermalPowerGeneratingAsset])
class ThermalPowerGenerationAirTemperatureModel(VulnerabilityModelBase):
    # Number of disrupted days per year
    _default_resource = "WRI thermal power plant physical climate vulnerability factors"
    _default_temperatures = [25.0, 30.0, 35.0, 40.0, 45.0, 50.0, 55.0]

    def __init__(self, *, resource: str = _default_resource, temperatures: List[float] = _default_temperatures):
        """
        Air temperature vulnerability model for thermal power generation.

        Args:
                resource (str): embedded resource identifier used to infer vulnerability table.
                temperatures (list[Float]): thresholds of the "days with average temperature above".
        """
        curve_set: VulnerabilityCurves = get_vulnerability_curves_from_resource(resource)

        # for this model, key for looking up curves is asset_type, e.g. 'Steam/Recirculating'
        self.vulnerability_curves = dict((c.asset_type, c) for c in curve_set.items if c.event_type == "AirTemperature")
        self.vuln_curves_by_type = defaultdict(list)
        for key in self.vulnerability_curves:
            self.vuln_curves_by_type[TurbineKind[key.split("/")[0]]].append(self.vulnerability_curves[key])

        impact_type = (
            ImpactType.disruption
            if len(self.vulnerability_curves) == 0
            else [ImpactType[self.vulnerability_curves[key].impact_type.lower()] for key in self.vulnerability_curves][
                0
            ]
        )

        self.temperatures = temperatures

        # global circulation parameter 'model' is a hint; can be overriden by hazard model
        super().__init__(indicator_id="days_tas/above/{temp_c}c", hazard_type=ChronicHeat, impact_type=impact_type)

    def get_data_requests(
        self, asset: Asset, *, scenario: str, year: int
    ) -> Union[HazardDataRequest, Iterable[HazardDataRequest]]:
        data_request = []
        for temperature in self.temperatures:
            data_request.append(
                HazardDataRequest(
                    self.hazard_type,
                    asset.longitude,
                    asset.latitude,
                    scenario=scenario,
                    year=year,
                    indicator_id=self.indicator_id.format(temp_c=str(int(temperature))),
                )
            )
        for temperature in self.temperatures:
            data_request.append(
                HazardDataRequest(
                    self.hazard_type,
                    asset.longitude,
                    asset.latitude,
                    scenario="historical",
                    year=2005,
                    indicator_id=self.indicator_id.format(temp_c=str(int(temperature))),
                )
            )
        return data_request

    def get_impact(self, asset: Asset, data_responses: List[HazardDataResponse]) -> ImpactDistrib:
        assert isinstance(asset, ThermalPowerGeneratingAsset)

        assert 2 * len(self.temperatures) == len(data_responses)

        # The unit being number of days per year, we divide by 365 to express the result as a year fraction.
        baseline = [
            cast(HazardParameterDataResponse, data_response).parameter / 365.0
            for data_response in data_responses[len(self.temperatures) :]
        ]

        # Threshold when it no longer makes technical or economical sense to keep power plant running.
        shutdown_air_temperature = 50

        # Temperature at which the power plant generates electricity with the designed maximum efficiency.
        design_air_temperature = np.interp(0.9, baseline[::-1], self.temperatures[::-1])

        intensities = np.array(
            [
                cast(HazardParameterDataResponse, data_response).parameter / 365.0
                for data_response in data_responses[: len(self.temperatures)]
            ]
        )
        intensities[:-1] -= intensities[1:]

        curves: List[VulnerabilityCurve] = []
        if asset.turbine is None:
            curves = [self.vulnerability_curves[key] for key in self.vulnerability_curves]
        elif asset.cooling is not None:
            key = "/".join([str(asset.turbine), str(asset.cooling)])
            if key in self.vulnerability_curves:
                curves = [self.vulnerability_curves[key]]
        elif asset.turbine in self.vuln_curves_by_type:
            curves = self.vuln_curves_by_type[asset.turbine]

        if 0 < len(curves):
            impacts = [
                (
                    1.0
                    if shutdown_air_temperature < temperature
                    else (
                        0.0
                        if temperature < design_air_temperature
                        else np.max(
                            [
                                np.interp(temperature - design_air_temperature, curve.intensity, curve.impact_mean)
                                for curve in curves
                            ]
                        )
                    )
                )
                for temperature in self.temperatures
            ]
        else:
            impacts = [0.0 for _ in self.temperatures]

        # The point injected at the beginning of impacts/intensities
        # allows to successfully call to_exceedance() as in API get_impact:
        impact_distrib = ImpactDistrib(
            self.hazard_type,
            [0.0] + impacts,
            np.concatenate((np.array([1.0 - sum(intensities)]), intensities)),
            self.impact_type,
        )
        return impact_distrib
