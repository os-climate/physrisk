import importlib.resources
from importlib import import_module
from typing import Dict, Optional, Sequence, Set

import physrisk.kernel.assets
from physrisk.kernel.assets import Asset
from physrisk.kernel.hazards import (
    CoastalInundation,
    IndicatorData,
    PluvialInundation,
    RiverineInundation,
    Wind,
    indicator_data,
)
from physrisk.kernel.impact_distrib import ImpactType
from physrisk.kernel.vulnerability_model import VulnerabilityModelBase
from physrisk.kernel.vulnerability_model import (
    VulnerabilityModels as PVulnerabilityModels,
)
from physrisk.kernel.vulnerability_model import (
    VulnerabilityModelsFactory as PVulnerabilityModelsFactory,
)
import physrisk.data.static.vulnerability
from physrisk.vulnerability_models.config_based_impact_curves import (
    VulnerabilityConfigItem,
    config_items_from_csv,
)
from physrisk.vulnerability_models.config_based_vuln_model_param import (
    ConfigBasedVulnerabilityModelParam,
)
from physrisk.vulnerability_models.config_based_vuln_model_acute import (
    ConfigBasedVulnerabilityModelAcute,
)
from physrisk.vulnerability_models.impact_function_selector import (
    CombinedImpactFunctionSelector,
    ConfigBasedImpactFunctionSelector,
    OEDHazusImpactFunctionSelector,
    VulnModelKey,
)

physrisk_assets = import_module("physrisk.kernel.assets")


def get_asset_type(asset_class: str):
    return getattr(
        physrisk_assets, asset_class, getattr(physrisk_assets, asset_class, None)
    )


class VulnerabilityModelsFactory(PVulnerabilityModelsFactory):
    def __init__(
        self,
        config: Sequence[VulnerabilityConfigItem] = [],
        programmatic_models: Dict[type[Asset], Sequence[VulnerabilityModelBase]] = {},
        use_oed_hazus_curves: bool = False,
    ):  # default_vulnerability_models):
        self.config_items = config
        oed_hazus_selector = OEDHazusImpactFunctionSelector(config)
        self.config_based_selector = ConfigBasedImpactFunctionSelector(config)
        self.combined_selector = CombinedImpactFunctionSelector(
            oed_hazus_selector, self.config_based_selector
        )
        self.programmatic_models = programmatic_models
        self.use_oed_hazus_curves = use_oed_hazus_curves

    def vulnerability_models(
        self,
        hazard_scope: Optional[Set[type]] = None,
        disable_api_calls=False,
    ) -> PVulnerabilityModels:
        return VulnerabilityModels(
            config_based_selector=self.config_based_selector,
            combined_selector=self.combined_selector,
            programmatic_models=self.programmatic_models,
            hazard_scope=hazard_scope,
            disable_api_calls=disable_api_calls,
            use_oed_hazus_curves=self.use_oed_hazus_curves,
        )

    @staticmethod
    def embedded_vulnerability_config():
        path = importlib.resources.files(physrisk.data.static.vulnerability).joinpath(
            "vulnerability_config.csv"
        )
        config = list(config_items_from_csv(str(path)))
        return config


class OEDHazusConfigBasedVulnerabilityModel(ConfigBasedVulnerabilityModelAcute):
    """Identical to ConfigBasedVulnerabilityModelAcute; name serves as a debugging convenience."""

    def __init__(self, **kwargs):
        super().__init__(**kwargs)


class VulnerabilityModels(PVulnerabilityModels):
    def __init__(
        self,
        config_based_selector: ConfigBasedImpactFunctionSelector,
        combined_selector: CombinedImpactFunctionSelector,
        programmatic_models: Dict[type[Asset], Sequence[VulnerabilityModelBase]] = {},
        hazard_scope: Optional[set[type[Asset]]] = None,
        disable_api_calls: bool = False,
        use_oed_hazus_curves=True,
    ):
        # this is called for each request, so must be fast (i.e. no file reads)
        # a dictionary of asset types to list of vulnerability models is prepared
        # the rules are
        # 1) add programmatic models
        # 2) optionally add inundation and wind 'OED Hazus' models
        # 3) add any config based models
        # 4) for each asset type, add any missing models from ancestors
        # in each case, models already present are *not* replaced
        # for 2, the models will first try to use Open Exposure Data (OED) properties to map
        # to Hazus impact curves. If no mapping is possible, any configuration present is used.
        # e.g. if there is a default flood curve for Asset, this will be picked up.

        self.hazard_scope = hazard_scope
        self.disable_api_calls = disable_api_calls

        all_models: dict[VulnModelKey, VulnerabilityModelBase] = {}

        # add programmatic models
        all_models.update(VulnerabilityModels.to_vuln_model_keys(programmatic_models))

        # add OED Hazus models
        if use_oed_hazus_curves:
            oed_hazus_models_dict = VulnerabilityModels.oed_hazus_models(
                combined_selector
            )
            for k, v in oed_hazus_models_dict.items():
                if k not in all_models:
                    all_models[k] = v

        # add config based models
        config_based_models_dict = VulnerabilityModels.config_based_models(
            config_based_selector
        )
        for k, v in config_based_models_dict.items():
            if k not in all_models:
                all_models[k] = v

        all_asset_types = set(k.asset_type for k in all_models.keys())
        # add any missing models from ancestors
        for asset_type in list(all_asset_types):
            for ancestor_type in asset_type.mro():
                if (
                    ancestor_type not in [object, asset_type]
                    and ancestor_type in all_asset_types
                ):
                    ancestor_keys_to_add = [
                        key
                        for key in all_models.keys()
                        if key.asset_type == ancestor_type
                    ]
                    for ancestor_key in ancestor_keys_to_add:
                        new_key = VulnModelKey(
                            asset_type,
                            ancestor_key.hazard_type,
                            ancestor_key.indicator_id,
                            ancestor_key.impact_type,
                        )
                        if new_key not in all_models:
                            all_models[new_key] = all_models[ancestor_key]

        # finally, convert to dict[type[Asset], list[VulnerabilityModelBase]]
        self.models: dict[type[Asset], list[VulnerabilityModelBase]] = {}
        for key, model in all_models.items():
            if key.asset_type not in self.models:
                self.models[key.asset_type] = []
            self.models[key.asset_type].append(model)

    def vuln_model_for_asset_of_type(
        self, asset_type: type[Asset]
    ) -> Sequence[VulnerabilityModelBase]:
        # if type is unknown, use models of closest ancestor
        models = self.models.get(Asset)
        for ancestor_type in asset_type.mro():  # includes asset_type itself
            if ancestor_type is not object and ancestor_type in self.models:
                models = self.models[ancestor_type]  # type:ignore
                break
        assert models is not None
        if self.hazard_scope:
            return [model for model in models if model.hazard_type in self.hazard_scope]
        return models

    @staticmethod
    def oed_hazus_models(selector: CombinedImpactFunctionSelector):
        """Create OED Hazus based vulnerability models for inundation and wind hazards.

        Args:
            selector (CombinedImpactFunctionSelector): Selector that includes OED Hazus mapping.
        Returns:
            dict[VulnModelKey, VulnerabilityModelBase]: Mapping to vulnerability models.
        """
        all_asset_types = physrisk.kernel.assets.all_asset_types()

        models: dict[VulnModelKey, VulnerabilityModelBase] = {}
        for hazard_type in [CoastalInundation, PluvialInundation, RiverineInundation]:
            indicator_id = "flood_depth"
            model = OEDHazusConfigBasedVulnerabilityModel(
                hazard_class=hazard_type,
                indicator_id=indicator_id,
                impact_type=ImpactType.damage,
                selector=selector,
            )
            for asset_type in all_asset_types:
                key = VulnModelKey(
                    asset_type, hazard_type, indicator_id, ImpactType.damage
                )
                models[key] = model

        indicator_id = "max_speed"
        model = OEDHazusConfigBasedVulnerabilityModel(
            hazard_class=Wind,
            indicator_id=indicator_id,
            impact_type=ImpactType.damage,
            selector=selector,
        )
        for asset_type in all_asset_types:
            key = VulnModelKey(asset_type, Wind, indicator_id, ImpactType.damage)
            models[key] = model
        return models

    @staticmethod
    def config_based_models(
        selector: ConfigBasedImpactFunctionSelector,
    ) -> dict[VulnModelKey, VulnerabilityModelBase]:
        """Create models implied by the vulnerability configuration. This has been read by ConfigBasedImpactFunctionSelector,
        and the available keys identified.

        Note that at this stage inheritance inheritance is not applied, e.g. if there is config for type Asset but not
        for RealEstateAsset, RealEstateAsset will not pick up the models of Asset.

        Args:
            selector (ConfigBasedImpactFunctionSelector): Impact function selector built from the vulnerability configuration.

        Returns:
            dict[VulnModelKey, VulnerabilityModelBase]: Mapping to vulnerability models.
        """
        # Each asset class has its own set of damage curves. The class has coarse granularity,
        # e.g. RealEstateAsset, PowerGeneratingAsset
        # with many types of asset covered by the class.
        models: dict[VulnModelKey, VulnerabilityModelBase] = {}

        for key in selector.keys():
            if indicator_data(key.hazard_type, key.indicator_id) == IndicatorData.EVENT:
                models[key] = ConfigBasedVulnerabilityModelAcute(
                    hazard_class=key.hazard_type,
                    indicator_id=key.indicator_id,
                    impact_type=key.impact_type,
                    selector=selector,
                )
            else:
                models[key] = ConfigBasedVulnerabilityModelParam(
                    hazard_class=key.hazard_type,
                    indicator_id=key.indicator_id,
                    impact_type=key.impact_type,
                    selector=selector,
                )
        return models

    @staticmethod
    def to_vuln_model_keys(models: dict[type[Asset], Sequence[VulnerabilityModelBase]]):
        result = {}
        for asset_type, model_list in models.items():
            for m in model_list:
                result[
                    VulnModelKey(
                        asset_type,
                        m.hazard_type,
                        m.indicator_id,
                        getattr(m, "impact_type", ImpactType.damage),
                    )
                ] = m
        return result
