import collections
import importlib.resources
from collections import defaultdict
from importlib import import_module
from operator import add
from typing import Dict, List, Optional, Sequence, Set, Type

from physrisk.kernel.assets import Asset
from physrisk.kernel.hazards import HazardKind
from physrisk.kernel.vulnerability_model import VulnerabilityModelBase
from physrisk.kernel.vulnerability_model import (
    VulnerabilityModels as PVulnerabilityModels,
)
from physrisk.kernel.vulnerability_model import (
    VulnerabilityModelsFactory as PVulnerabilityModelsFactory,
)
import physrisk.data
from physrisk.vulnerability_models.config_based_model import (
    ConfigBasedVulnerabilityModel,
    ConfigBasedVulnerabilityModelAcute,
    VulnerabilityConfigItem,
    config_items_from_csv,
)

physrisk_assets = import_module("physrisk.kernel.assets")


def get_asset_type(asset_class: str):
    return getattr(
        physrisk_assets, asset_class, getattr(physrisk_assets, asset_class, None)
    )


class VulnerabilityModelsFactory(PVulnerabilityModelsFactory):
    def __init__(self, config: Sequence[VulnerabilityConfigItem] = []):
        self.config = config

    def vulnerability_models(
        self,
        hazard_scope: Optional[Set[type]] = None,
        disable_api_calls=False,
    ) -> PVulnerabilityModels:
        return VulnerabilityModels(self.config, hazard_scope, disable_api_calls)

    @staticmethod
    def embedded_vulnerability_config():
        with importlib.resources.path(
            physrisk.data, "vulnerability_config.csv"
        ) as path:
            config = config_items_from_csv(str(path))
        return config


class VulnerabilityModels(PVulnerabilityModels):
    def __init__(
        self,
        config: Sequence[VulnerabilityConfigItem] = [],
        hazard_scope: Optional[Set[type]] = None,
        disable_api_calls=False,
    ):
        self.hazard_scope = hazard_scope
        self.disable_api_calls = disable_api_calls
        self.models: Dict[Type[Asset], Sequence[VulnerabilityModelBase]] = (
            self.programmatic_models()
        )
        # the config-based models always 'win'
        # add any config based models to the programmatic models
        if any(config):
            config_based_models = self.config_based_models(config)
            for k, v in config_based_models.items():
                if k in self.models:
                    keys = [
                        (m.hazard_type, m.indicator_id, getattr(m, "impact_type", None))
                        for m in v
                    ]
                    self.models[k] = add(
                        v,
                        [
                            m
                            for m in self.models[k]
                            if (
                                m.hazard_type,
                                m.indicator_id,
                                getattr(m, "impact_type", None),
                            )
                            not in keys
                        ],
                    )
                else:
                    self.models[k] = v
        ancestors = dict(
            sorted(
                dict({key: key.mro() for key in self.models}).items(),
                key=lambda item: len(item[1]),
            )
        )
        # if extra models can be added from ancestors (e.g. Asset defines damage functions not present for sub-type
        # (aka derived class)) then add also
        for k, v in ancestors.items():
            keys = [
                (m.hazard_type, m.indicator_id, getattr(m, "impact_type", None))
                for m in self.models[k]
            ]
            for asset_class in v:
                if asset_class not in [k, object] and asset_class in self.models:
                    self.models[k] = add(
                        self.models[k],
                        [
                            m
                            for m in self.models[asset_class]
                            if (
                                m.hazard_type,
                                m.indicator_id,
                                getattr(m, "impact_type", None),
                            )
                            not in keys
                        ],
                    )
                    keys = [
                        (m.hazard_type, m.indicator_id, getattr(m, "impact_type", None))
                        for m in self.models[k]
                    ]

        # Check if hazard is covered exactly once.
        for models in self.models.values():
            keys = [
                (m.hazard_type, m.indicator_id, getattr(m, "impact_type", None))
                for m in models
            ]
            if len(set(keys)) != len(keys):
                raise ValueError("")

    def vuln_model_for_asset_of_type(
        self, type: Type[Asset]
    ) -> Sequence[VulnerabilityModelBase]:
        # models = self.models.get(Asset)
        models = self.models.get(Asset)
        for asset_class_type in type.mro():
            if asset_class_type is not object and asset_class_type in self.models:
                models = self.models[asset_class_type]  # type:ignore
                break
        assert models is not None
        if self.hazard_scope:
            return [model for model in models if model.hazard_type in self.hazard_scope]
        return models

    def config_based_models(self, config: Sequence[VulnerabilityConfigItem]):
        physrisk_hazards = import_module("physrisk.kernel.hazards")
        # Each asset class has its own set of damage curves. The class has coarse granularity,
        # e.g. RealEstateAsset, PowerGeneratingAsset
        # with many types of asset covered by the class.
        models: Dict[Type[Asset], List[VulnerabilityModelBase]] = defaultdict(list)

        items_by_asset_class: Dict[Type[Asset], List[VulnerabilityConfigItem]] = (
            defaultdict(list)
        )

        for item in config:
            items_by_asset_class[get_asset_type(item.asset_class)].append(item)

        ancestors = dict(
            sorted(
                dict({key: key.mro() for key in items_by_asset_class}).items(),
                key=lambda item: len(item[1]),
            )
        )
        for k, v in ancestors.items():
            keys = [
                (
                    item.hazard_class,
                    item.asset_identifier,
                    item.indicator_id,
                    item.impact_id,
                )
                for item in items_by_asset_class[k]
            ]
            for asset_class in v:
                if (
                    asset_class not in [k, object]
                    and asset_class in items_by_asset_class
                ):
                    items_by_asset_class[k] = add(
                        items_by_asset_class[k],
                        [
                            item
                            for item in items_by_asset_class[asset_class]
                            if (
                                item.hazard_class,
                                item.asset_identifier,
                                item.indicator_id,
                                item.impact_id,
                            )
                            not in keys
                        ],
                    )
                    keys = [
                        (
                            item.hazard_class,
                            item.asset_identifier,
                            item.indicator_id,
                            item.impact_id,
                        )
                        for item in items_by_asset_class[k]
                    ]

        Key = collections.namedtuple("Key", ["hazard_class", "impact_id"])
        for asset_class, items in items_by_asset_class.items():
            try:
                # asset_class = getattr(physrisk_assets, item.asset_class)
                # we do not demand that the asset-class exists in code.
                grouped_items: Dict[Key, List[VulnerabilityConfigItem]] = defaultdict(
                    list
                )
                for item in items:
                    grouped_items[Key(item.hazard_class, item.impact_id)].append(item)
                for key in grouped_items:
                    hazard_class = getattr(physrisk_hazards, key.hazard_class)
                    if hazard_class.kind == HazardKind.ACUTE:
                        models[asset_class].append(
                            ConfigBasedVulnerabilityModelAcute(
                                asset_class=asset_class.__name__,
                                hazard_class=hazard_class,
                                impact_id=key.impact_id,
                                config_items=grouped_items[key],
                            )
                        )
                    else:
                        models[asset_class].append(
                            ConfigBasedVulnerabilityModel(
                                asset_class=asset_class.__name__,
                                hazard_class=hazard_class,
                                impact_id=key.impact_id,
                                config_items=grouped_items[key],
                            )
                        )
            except Exception:
                raise ValueError(
                    f"Could not convert config item with asset {asset_class.__name__} "
                    + f"and hazard {hazard_class.__name__}."
                )
        return models

    def programmatic_models(
        self,
    ) -> Dict[Type[Asset], Sequence[VulnerabilityModelBase]]:
        return {}
