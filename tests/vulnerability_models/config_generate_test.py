import json
import numpy as np
import pandas as pd

from physrisk.kernel.assets import RealEstateAsset
from physrisk.kernel.hazards import (
    CoastalInundation,
    PluvialInundation,
    RiverineInundation,
)
from physrisk.kernel.impact_distrib import ImpactType
from physrisk.vulnerability_models.config_based_model import (
    VulnerabilityConfigItem,
    config_items_to_csv,
)


def test_generate_all_config(vulnerability_onboarding_dir):
    """Generate all vulnerability config. This is done via test because:
    - this ensures that the config remains traceable to source and
    - in general the process is not compute-intensive.

    Args:
        vulnerability_onboarding_dir (Path): Path to vulnerability on-boarding data directory.
    """
    config_items = generate_all_config(vulnerability_onboarding_dir)
    config_items_to_csv(
        config_items, vulnerability_onboarding_dir / "candidate_config.csv"
    )


def generate_all_config(vulnerability_onboarding_dir):
    config_items: list[VulnerabilityConfigItem] = []
    config_items += flood_config_jrc(vulnerability_onboarding_dir)
    return config_items


def flood_config_jrc(vulnerability_onboarding_dir):
    """Create vulnerability config for flood based on the EU JRC global depth-damage functions.
    This replaces the notebook implementation and sets the pattern for code-based generation of the config.

    Args:
        vulnerability_onboarding_dir (_type_): Path to vulnerability on-boarding data directory.
    """
    # raw data is actually a reformatting of the original Excel spreadsheet to facilitate loading.
    raw_data = vulnerability_onboarding_dir / "inundation_jrc" / "raw.csv"
    df = pd.read_csv(raw_data)

    # consistent with physrisk continent definition
    location_mappings = {
        "Europe": "Europe",
        "North America": "North America",
        "Central & South America": "South America",
        "Asia": "Asia",
        "Africa": "Africa",
        "Oceania": "Oceania",
        "Global": "Global",
    }
    type_mappings = {
        "Residential buildings": "Buildings/Residential",
        "Commercial buildings": "Buildings/Commercial",
        "Industrial buildings": "Buildings/Industrial",
    }

    config_items: list[VulnerabilityConfigItem] = []
    for mapping in type_mappings:
        type_df = df[df["Type"] == mapping]
        flood_depth = type_df["Flood depth [m]"].to_numpy()
        for location in location_mappings:
            # whether zero depth is considered really zero or a flood event with smallest depth
            zero_as_minimum = True if location == "North America" else False
            # for North America, the 0 depth damage is for flooding of any depth. We consider that a 1 cm inundation.
            depth = (
                np.concatenate([[0, 0.01], flood_depth[1:]])
                if zero_as_minimum
                else flood_depth
            )

            mean = type_df[location + "_Mean"].to_numpy()
            std = type_df[location + "_Std"].to_numpy()
            mean = np.concatenate([[0], mean]) if zero_as_minimum else mean
            std = np.concatenate([[0], std]) if zero_as_minimum else std
            if np.any(np.isnan(mean)):
                mean = []
            if np.any(np.isnan(std)):
                std = []
            if not any(mean):
                continue
            config_items.append(
                VulnerabilityConfigItem(
                    hazard_class=",".join(
                        [
                            CoastalInundation.__name__,
                            PluvialInundation.__name__,
                            RiverineInundation.__name__,
                        ]
                    ),
                    asset_class=RealEstateAsset.__name__,
                    asset_identifier=f"type={type_mappings[mapping]},location={location_mappings[location]}",
                    indicator_id="flood_depth",
                    indicator_units="metres",
                    impact_id=str(ImpactType.damage.name),
                    curve_type="indicator/piecewise_linear",
                    points_x=list(depth),
                    points_y=list(mean),
                    # points_z=std, # omit for now: until implemented
                )
            )
    return config_items
